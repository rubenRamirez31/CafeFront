"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdb-react-ui-kit";
exports.ids = ["vendor-chunks/mdb-react-ui-kit"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdb-react-ui-kit/node_modules/@popperjs/core/dist/cjs/popper.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/mdb-react-ui-kit/node_modules/@popperjs/core/dist/cjs/popper.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @popperjs/core v2.11.5 - MIT License\n */\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  var rect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (isHTMLElement(element) && includeScale) {\n    var offsetHeight = element.offsetHeight;\n    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n    // Fallback to 1 in case both values are `0`\n\n    if (offsetWidth > 0) {\n      scaleX = round(rect.width) / offsetWidth || 1;\n    }\n\n    if (offsetHeight > 0) {\n      scaleY = round(rect.height) / offsetHeight || 1;\n    }\n  }\n\n  return {\n    width: rect.width / scaleX,\n    height: rect.height / scaleY,\n    top: rect.top / scaleY,\n    right: rect.right / scaleX,\n    bottom: rect.bottom / scaleY,\n    left: rect.left / scaleX,\n    x: rect.left / scaleX,\n    y: rect.top / scaleY\n  };\n}\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n  var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nvar top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n\nfunction format(str) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return [].concat(args).reduce(function (p, c) {\n    return p.replace(/%s/, c);\n  }, str);\n}\n\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];\nfunction validateModifiers(modifiers) {\n  modifiers.forEach(function (modifier) {\n    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`\n    .filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    }).forEach(function (key) {\n      switch (key) {\n        case 'name':\n          if (typeof modifier.name !== 'string') {\n            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', \"\\\"\" + String(modifier.name) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'enabled':\n          if (typeof modifier.enabled !== 'boolean') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', \"\\\"\" + String(modifier.enabled) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'phase':\n          if (modifierPhases.indexOf(modifier.phase) < 0) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(', '), \"\\\"\" + String(modifier.phase) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'fn':\n          if (typeof modifier.fn !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'effect':\n          if (modifier.effect != null && typeof modifier.effect !== 'function') {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', \"\\\"\" + String(modifier.fn) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requires':\n          if (modifier.requires != null && !Array.isArray(modifier.requires)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', \"\\\"\" + String(modifier.requires) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'requiresIfExists':\n          if (!Array.isArray(modifier.requiresIfExists)) {\n            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', \"\\\"\" + String(modifier.requiresIfExists) + \"\\\"\"));\n          }\n\n          break;\n\n        case 'options':\n        case 'data':\n          break;\n\n        default:\n          console.error(\"PopperJS: an invalid property has been provided to the \\\"\" + modifier.name + \"\\\" modifier, valid properties are \" + VALID_PROPERTIES.map(function (s) {\n            return \"\\\"\" + s + \"\\\"\";\n          }).join(', ') + \"; but \\\"\" + key + \"\\\" was provided.\");\n      }\n\n      modifier.requires && modifier.requires.forEach(function (requirement) {\n        if (modifiers.find(function (mod) {\n          return mod.name === requirement;\n        }) == null) {\n          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n        }\n      });\n    });\n  });\n}\n\nfunction uniqueBy(arr, fn) {\n  var identifiers = new Set();\n  return arr.filter(function (item) {\n    var identifier = fn(item);\n\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n  // can be obscured underneath it.\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n  // if it isn't open, so if this isn't available, the popper will be detected\n  // to overflow the bottom of the screen too early.\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n    // Feature detection fails in mobile emulation mode in Chrome.\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n    // 0.001\n    // Fallback here: \"Not Safari\" userAgent\n\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n    }\n  }\n\n  return offsets;\n}\n\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (true) {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (true) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (true) {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (true) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nvar passive = {\n  passive: true\n};\n\nfunction effect$2(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar eventListeners = {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect$2,\n  data: {}\n};\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar popperOffsets$1 = {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n\n  if (true) {\n    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar computeStyles$1 = {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};\n\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect$1(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar applyStyles$1 = {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect$1,\n  requires: ['computeStyles']\n};\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar offset$1 = {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};\n\nvar hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash$1[matched];\n  });\n}\n\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements$1.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements$1;\n\n    if (true) {\n      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(' '));\n    }\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar flip$1 = {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};\n\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min$1 = offset + overflow[mainSide];\n    var max$1 = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar preventOverflow$1 = {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (true) {\n    if (!isHTMLElement(arrowElement)) {\n      console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (true) {\n      console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', 'element.'].join(' '));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar arrow$1 = {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nvar hide$1 = {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};\n\nvar defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];\nvar createPopper$1 = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers$1\n}); // eslint-disable-next-line import/no-unused-modules\n\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexports.applyStyles = applyStyles$1;\nexports.arrow = arrow$1;\nexports.computeStyles = computeStyles$1;\nexports.createPopper = createPopper;\nexports.createPopperLite = createPopper$1;\nexports.defaultModifiers = defaultModifiers;\nexports.detectOverflow = detectOverflow;\nexports.eventListeners = eventListeners;\nexports.flip = flip$1;\nexports.hide = hide$1;\nexports.offset = offset$1;\nexports.popperGenerator = popperGenerator;\nexports.popperOffsets = popperOffsets$1;\nexports.preventOverflow = preventOverflow$1;\n//# sourceMappingURL=popper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRiLXJlYWN0LXVpLWtpdC9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvZGlzdC9janMvcG9wcGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLE9BQU87O0FBRVI7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsb0NBQW9DO0FBQy9EOztBQUVBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxtREFBbUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx5Q0FBeUMsa0RBQWtEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLDRDQUE0QztBQUM1QztBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7O0FBRXZIO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSSxHQUFHOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FO0FBQ25FO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSixtQkFBbUI7QUFDbkIsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGluaW5vYXBwLy4vbm9kZV9tb2R1bGVzL21kYi1yZWFjdC11aS1raXQvbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2Rpc3QvY2pzL3BvcHBlci5qcz9iODc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBvcHBlcmpzL2NvcmUgdjIuMTEuNSAtIE1JVCBMaWNlbnNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGluY2x1ZGVTY2FsZSkge1xuICAgIHZhciBvZmZzZXRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoOyAvLyBEbyBub3QgYXR0ZW1wdCB0byBkaXZpZGUgYnkgMCwgb3RoZXJ3aXNlIHdlIGdldCBgSW5maW5pdHlgIGFzIHNjYWxlXG4gICAgLy8gRmFsbGJhY2sgdG8gMSBpbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBgMGBcblxuICAgIGlmIChvZmZzZXRXaWR0aCA+IDApIHtcbiAgICAgIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gb2Zmc2V0V2lkdGggfHwgMTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0SGVpZ2h0ID4gMCkge1xuICAgICAgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gb2Zmc2V0SGVpZ2h0IHx8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAvIHNjYWxlWCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gc2NhbGVZLFxuICAgIHRvcDogcmVjdC50b3AgLyBzY2FsZVksXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQgLyBzY2FsZVgsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSAvIHNjYWxlWSxcbiAgICBsZWZ0OiByZWN0LmxlZnQgLyBzY2FsZVgsXG4gICAgeDogcmVjdC5sZWZ0IC8gc2NhbGVYLFxuICAgIHk6IHJlY3QudG9wIC8gc2NhbGVZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5mdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn1cblxuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59XG5cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcbiAgdmFyIGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTE7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG5cbnZhciB0b3AgPSAndG9wJztcbnZhciBib3R0b20gPSAnYm90dG9tJztcbnZhciByaWdodCA9ICdyaWdodCc7XG52YXIgbGVmdCA9ICdsZWZ0JztcbnZhciBhdXRvID0gJ2F1dG8nO1xudmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG52YXIgc3RhcnQgPSAnc3RhcnQnO1xudmFyIGVuZCA9ICdlbmQnO1xudmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xudmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbnZhciBwb3BwZXIgPSAncG9wcGVyJztcbnZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbnZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG52YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG52YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbnZhciByZWFkID0gJ3JlYWQnO1xudmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG52YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbnZhciBtYWluID0gJ21haW4nO1xudmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbnZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG52YXIgd3JpdGUgPSAnd3JpdGUnO1xudmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG52YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KHN0cikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gW10uY29uY2F0KGFyZ3MpLnJlZHVjZShmdW5jdGlvbiAocCwgYykge1xuICAgIHJldHVybiBwLnJlcGxhY2UoLyVzLywgYyk7XG4gIH0sIHN0cik7XG59XG5cbnZhciBJTlZBTElEX01PRElGSUVSX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHByb3ZpZGVkIGFuIGludmFsaWQgJXMgcHJvcGVydHksIGV4cGVjdGVkICVzIGJ1dCBnb3QgJXMnO1xudmFyIE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiByZXF1aXJlcyBcIiVzXCIsIGJ1dCBcIiVzXCIgbW9kaWZpZXIgaXMgbm90IGF2YWlsYWJsZSc7XG52YXIgVkFMSURfUFJPUEVSVElFUyA9IFsnbmFtZScsICdlbmFibGVkJywgJ3BoYXNlJywgJ2ZuJywgJ2VmZmVjdCcsICdyZXF1aXJlcycsICdvcHRpb25zJ107XG5mdW5jdGlvbiB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgW10uY29uY2F0KE9iamVjdC5rZXlzKG1vZGlmaWVyKSwgVkFMSURfUFJPUEVSVElFUykgLy8gSUUxMS1jb21wYXRpYmxlIHJlcGxhY2VtZW50IGZvciBgbmV3IFNldChpdGVyYWJsZSlgXG4gICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksICdcIm5hbWVcIicsICdcInN0cmluZ1wiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIubmFtZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2VuYWJsZWQnOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZW5hYmxlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJlbmFibGVkXCInLCAnXCJib29sZWFuXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5lbmFibGVkKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGhhc2UnOlxuICAgICAgICAgIGlmIChtb2RpZmllclBoYXNlcy5pbmRleE9mKG1vZGlmaWVyLnBoYXNlKSA8IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInBoYXNlXCInLCBcImVpdGhlciBcIiArIG1vZGlmaWVyUGhhc2VzLmpvaW4oJywgJyksIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnBoYXNlKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZm4nOlxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcImZuXCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlZmZlY3QnOlxuICAgICAgICAgIGlmIChtb2RpZmllci5lZmZlY3QgIT0gbnVsbCAmJiB0eXBlb2YgbW9kaWZpZXIuZWZmZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJlZmZlY3RcIicsICdcImZ1bmN0aW9uXCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzJzpcbiAgICAgICAgICBpZiAobW9kaWZpZXIucmVxdWlyZXMgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShtb2RpZmllci5yZXF1aXJlcykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInJlcXVpcmVzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXMpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlc0lmRXhpc3RzJzpcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcInJlcXVpcmVzSWZFeGlzdHNcIicsICdcImFycmF5XCInLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb3B0aW9ucyc6XG4gICAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlBvcHBlckpTOiBhbiBpbnZhbGlkIHByb3BlcnR5IGhhcyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBcXFwiXCIgKyBtb2RpZmllci5uYW1lICsgXCJcXFwiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSBcIiArIFZBTElEX1BST1BFUlRJRVMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBzICsgXCJcXFwiXCI7XG4gICAgICAgICAgfSkuam9pbignLCAnKSArIFwiOyBidXQgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBwcm92aWRlZC5cIik7XG4gICAgICB9XG5cbiAgICAgIG1vZGlmaWVyLnJlcXVpcmVzICYmIG1vZGlmaWVyLnJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVpcmVtZW50KSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMuZmluZChmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZC5uYW1lID09PSByZXF1aXJlbWVudDtcbiAgICAgICAgfSkgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0KE1JU1NJTkdfREVQRU5ERU5DWV9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCByZXF1aXJlbWVudCwgcmVxdWlyZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1bmlxdWVCeShhcnIsIGZuKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IGZuKGl0ZW0pO1xuXG4gICAgaWYgKCFpZGVudGlmaWVycy5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgIGlkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufVxuXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5cbmZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59XG5cbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0JDIoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBldmVudExpc3RlbmVycyA9IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCQyLFxuICBkYXRhOiB7fVxufTtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcG9wcGVyT2Zmc2V0cyQxID0ge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTtcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgY29tcHV0ZVN0eWxlcyQxID0ge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07XG5cbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdCQxKF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgYXBwbHlTdHlsZXMkMSA9IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QkMSxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59O1xuXG5mdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIG9mZnNldCQxID0ge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59O1xuXG52YXIgaGFzaCQxID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2gkMVttYXRjaGVkXTtcbiAgfSk7XG59XG5cbnZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBwbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzJDEgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMkMTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBmbGlwJDEgPSB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbihtaW4kMSwgdmFsdWUsIG1heCQxKSB7XG4gIHJldHVybiBtYXgobWluJDEsIG1pbih2YWx1ZSwgbWF4JDEpKTtcbn1cbmZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluJDEgPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCQxID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1pbihtaW4kMSwgdGV0aGVyTWluKSA6IG1pbiQxLCBvZmZzZXQsIHRldGhlciA/IG1heChtYXgkMSwgdGV0aGVyTWF4KSA6IG1heCQxKTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgcHJldmVudE92ZXJmbG93JDEgPSB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59O1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGFycm93JDEgPSB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGhpZGUkMSA9IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTtcblxudmFyIGRlZmF1bHRNb2RpZmllcnMkMSA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cyQxLCBjb21wdXRlU3R5bGVzJDEsIGFwcGx5U3R5bGVzJDFdO1xudmFyIGNyZWF0ZVBvcHBlciQxID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnMkMVxufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxLCBvZmZzZXQkMSwgZmxpcCQxLCBwcmV2ZW50T3ZlcmZsb3ckMSwgYXJyb3ckMSwgaGlkZSQxXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0cy5hcHBseVN0eWxlcyA9IGFwcGx5U3R5bGVzJDE7XG5leHBvcnRzLmFycm93ID0gYXJyb3ckMTtcbmV4cG9ydHMuY29tcHV0ZVN0eWxlcyA9IGNvbXB1dGVTdHlsZXMkMTtcbmV4cG9ydHMuY3JlYXRlUG9wcGVyID0gY3JlYXRlUG9wcGVyO1xuZXhwb3J0cy5jcmVhdGVQb3BwZXJMaXRlID0gY3JlYXRlUG9wcGVyJDE7XG5leHBvcnRzLmRlZmF1bHRNb2RpZmllcnMgPSBkZWZhdWx0TW9kaWZpZXJzO1xuZXhwb3J0cy5kZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93O1xuZXhwb3J0cy5ldmVudExpc3RlbmVycyA9IGV2ZW50TGlzdGVuZXJzO1xuZXhwb3J0cy5mbGlwID0gZmxpcCQxO1xuZXhwb3J0cy5oaWRlID0gaGlkZSQxO1xuZXhwb3J0cy5vZmZzZXQgPSBvZmZzZXQkMTtcbmV4cG9ydHMucG9wcGVyR2VuZXJhdG9yID0gcG9wcGVyR2VuZXJhdG9yO1xuZXhwb3J0cy5wb3BwZXJPZmZzZXRzID0gcG9wcGVyT2Zmc2V0cyQxO1xuZXhwb3J0cy5wcmV2ZW50T3ZlcmZsb3cgPSBwcmV2ZW50T3ZlcmZsb3ckMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdb-react-ui-kit/node_modules/@popperjs/core/dist/cjs/popper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mdb-react-ui-kit/dist/mdb-react-ui-kit.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/mdb-react-ui-kit/dist/mdb-react-ui-kit.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MDBAccordion: () => (/* binding */ _t),\n/* harmony export */   MDBAccordionItem: () => (/* binding */ jt),\n/* harmony export */   MDBBadge: () => (/* binding */ Ie),\n/* harmony export */   MDBBreadcrumb: () => (/* binding */ qe),\n/* harmony export */   MDBBreadcrumbItem: () => (/* binding */ Ke),\n/* harmony export */   MDBBtn: () => (/* binding */ le),\n/* harmony export */   MDBBtnGroup: () => (/* binding */ ke),\n/* harmony export */   MDBCard: () => (/* binding */ Ce),\n/* harmony export */   MDBCardBody: () => (/* binding */ He),\n/* harmony export */   MDBCardFooter: () => (/* binding */ We),\n/* harmony export */   MDBCardGroup: () => (/* binding */ _e),\n/* harmony export */   MDBCardHeader: () => (/* binding */ Ae),\n/* harmony export */   MDBCardImage: () => (/* binding */ Qt),\n/* harmony export */   MDBCardLink: () => (/* binding */ Zt),\n/* harmony export */   MDBCardOverlay: () => (/* binding */ Xe),\n/* harmony export */   MDBCardSubTitle: () => (/* binding */ Pe),\n/* harmony export */   MDBCardText: () => (/* binding */ Oe),\n/* harmony export */   MDBCardTitle: () => (/* binding */ Fe),\n/* harmony export */   MDBCarousel: () => (/* binding */ Ns),\n/* harmony export */   MDBCarouselCaption: () => (/* binding */ Bs),\n/* harmony export */   MDBCarouselItem: () => (/* binding */ ws),\n/* harmony export */   MDBCheckbox: () => (/* binding */ ns),\n/* harmony export */   MDBCol: () => (/* binding */ Ee),\n/* harmony export */   MDBCollapse: () => (/* binding */ dt),\n/* harmony export */   MDBContainer: () => (/* binding */ $e),\n/* harmony export */   MDBDropdown: () => (/* binding */ os),\n/* harmony export */   MDBDropdownItem: () => (/* binding */ cs),\n/* harmony export */   MDBDropdownMenu: () => (/* binding */ ls),\n/* harmony export */   MDBDropdownToggle: () => (/* binding */ is),\n/* harmony export */   MDBFile: () => (/* binding */ ys),\n/* harmony export */   MDBFooter: () => (/* binding */ st),\n/* harmony export */   MDBIcon: () => (/* binding */ es),\n/* harmony export */   MDBInput: () => (/* binding */ it),\n/* harmony export */   MDBInputGroup: () => (/* binding */ Rt),\n/* harmony export */   MDBListGroup: () => (/* binding */ je),\n/* harmony export */   MDBListGroupItem: () => (/* binding */ Ge),\n/* harmony export */   MDBModal: () => (/* binding */ fs),\n/* harmony export */   MDBModalBody: () => (/* binding */ Mt),\n/* harmony export */   MDBModalContent: () => (/* binding */ Nt),\n/* harmony export */   MDBModalDialog: () => (/* binding */ yt),\n/* harmony export */   MDBModalFooter: () => (/* binding */ Dt),\n/* harmony export */   MDBModalHeader: () => (/* binding */ wt),\n/* harmony export */   MDBModalTitle: () => (/* binding */ Bt),\n/* harmony export */   MDBNavbar: () => (/* binding */ Je),\n/* harmony export */   MDBNavbarBrand: () => (/* binding */ Ze),\n/* harmony export */   MDBNavbarItem: () => (/* binding */ ze),\n/* harmony export */   MDBNavbarLink: () => (/* binding */ Qe),\n/* harmony export */   MDBNavbarNav: () => (/* binding */ et),\n/* harmony export */   MDBNavbarToggler: () => (/* binding */ tt),\n/* harmony export */   MDBPagination: () => (/* binding */ rt),\n/* harmony export */   MDBPaginationItem: () => (/* binding */ at),\n/* harmony export */   MDBPaginationLink: () => (/* binding */ nt),\n/* harmony export */   MDBPopover: () => (/* binding */ ds),\n/* harmony export */   MDBPopoverBody: () => (/* binding */ us),\n/* harmony export */   MDBPopoverHeader: () => (/* binding */ ms),\n/* harmony export */   MDBProgress: () => (/* binding */ ot),\n/* harmony export */   MDBProgressBar: () => (/* binding */ Ne),\n/* harmony export */   MDBRadio: () => (/* binding */ as),\n/* harmony export */   MDBRange: () => (/* binding */ vs),\n/* harmony export */   MDBRipple: () => (/* binding */ ye),\n/* harmony export */   MDBRow: () => (/* binding */ Ye),\n/* harmony export */   MDBScrollspy: () => (/* binding */ ps),\n/* harmony export */   MDBScrollspyLink: () => (/* binding */ gs),\n/* harmony export */   MDBScrollspySubList: () => (/* binding */ hs),\n/* harmony export */   MDBSpinner: () => (/* binding */ Se),\n/* harmony export */   MDBSwitch: () => (/* binding */ bs),\n/* harmony export */   MDBTable: () => (/* binding */ ts),\n/* harmony export */   MDBTableBody: () => (/* binding */ rs),\n/* harmony export */   MDBTableHead: () => (/* binding */ ss),\n/* harmony export */   MDBTabs: () => (/* binding */ Et),\n/* harmony export */   MDBTabsContent: () => (/* binding */ xt),\n/* harmony export */   MDBTabsItem: () => (/* binding */ It),\n/* harmony export */   MDBTabsLink: () => (/* binding */ Lt),\n/* harmony export */   MDBTabsPane: () => (/* binding */ kt),\n/* harmony export */   MDBTextArea: () => (/* binding */ Ms),\n/* harmony export */   MDBTooltip: () => (/* binding */ zt),\n/* harmony export */   MDBTypography: () => (/* binding */ Ve),\n/* harmony export */   MDBValidation: () => (/* binding */ $t),\n/* harmony export */   MDBValidationItem: () => (/* binding */ Ds)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_popper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-popper */ \"(ssr)/./node_modules/react-popper/lib/cjs/index.js\");\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @popperjs/core */ \"(ssr)/./node_modules/mdb-react-ui-kit/node_modules/@popperjs/core/dist/cjs/popper.js\");\n(function(){\"use strict\";try{if(typeof document!=\"undefined\"){var o=document.createElement(\"style\");o.appendChild(document.createTextNode(\".dropdown-menu .active:not(.form-control){color:#16181b;background-color:#eee}.dropdown-menu [data-active=true] a.dropdown-item,.dropdown-menu .dropdown-item:focus,.dropdown-menu li:focus .dropdown-item :not(.disabled){color:#16181b;background-color:#eee}.dropdown-menu li:focus{outline:none}.dropdown-menu.dropdown-menu-dark [data-active=true] a.dropdown-item,.dropdown-menu.dropdown-menu-dark .dropdown-item:focus,.dropdown-menu.dropdown-menu-dark li:focus .dropdown-item{color:#fff;background-color:#1266f1}.btn-group.dropstart>.dropdown-menu{right:0!important}\")),document.head.appendChild(o)}}catch(d){console.error(\"vite-plugin-css-injected-by-js\",d)}})();\n\n\n\n\n\n\nconst $e = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ breakpoint: e, fluid: t, children: s, className: r, tag: n = \"div\", ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(`${t ? \"container-fluid\" : `container${e ? \"-\" + e : \"\"}`}`, r);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, { className: o, ...a, ref: c, children: s });\n  }\n);\n$e.displayName = \"MDBContainer\";\nconst Ee = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    center: e,\n    children: t,\n    className: s,\n    end: r,\n    lg: n,\n    md: a,\n    offsetLg: c,\n    offsetMd: o,\n    offsetSm: i,\n    order: u,\n    size: d,\n    sm: p,\n    start: m,\n    tag: g = \"div\",\n    xl: h,\n    xxl: v,\n    xs: b,\n    ...T\n  }, R) => {\n    const N = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      d && `col-${d}`,\n      b && `col-xs-${b}`,\n      p && `col-sm-${p}`,\n      a && `col-md-${a}`,\n      n && `col-lg-${n}`,\n      h && `col-xl-${h}`,\n      v && `col-xxl-${v}`,\n      !d && !b && !p && !a && !n && !h && !v ? \"col\" : \"\",\n      u && `order-${u}`,\n      m && \"align-self-start\",\n      e && \"align-self-center\",\n      r && \"align-self-end\",\n      i && `offset-sm-${i}`,\n      o && `offset-md-${o}`,\n      c && `offset-lg-${c}`,\n      s\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(g, { className: N, ref: R, ...T, children: t });\n  }\n);\nEe.displayName = \"MDBCol\";\nconst Ie = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, color: t = \"primary\", pill: s, light: r, dot: n, tag: a = \"span\", children: c, notification: o, ...i }, u) => {\n    const d = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"badge\",\n      r ? t && `badge-${t}` : t && `bg-${t}`,\n      n && \"badge-dot\",\n      s && \"rounded-pill\",\n      o && \"badge-notification\",\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { className: d, ref: u, ...i, children: c });\n  }\n);\nIe.displayName = \"MDBBadge\";\nconst Le = ({ ...e }) => {\n  const [t, s] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), r = clsx__WEBPACK_IMPORTED_MODULE_2__(\"ripple-wave\", t && \"active\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const n = setTimeout(() => {\n      s(!0);\n    }, 50);\n    return () => {\n      clearTimeout(n);\n    };\n  }, []), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: r, ...e });\n}, xe = (...e) => {\n  const t = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n  return react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    e.forEach((s) => {\n      s && (typeof s == \"function\" ? s(t.current) : s.current = t.current);\n    });\n  }, [e]), t;\n}, ye = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    className: e,\n    rippleTag: t = \"div\",\n    rippleCentered: s,\n    rippleDuration: r = 500,\n    rippleUnbound: n,\n    rippleRadius: a = 0,\n    rippleColor: c = \"dark\",\n    children: o,\n    onMouseDown: i,\n    ...u\n  }, d) => {\n    const p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), m = xe(d, p), g = \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\", h = [0, 0, 0], v = [\"primary\", \"secondary\", \"success\", \"danger\", \"warning\", \"info\", \"light\", \"dark\"], [b, T] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]), [R, N] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), k = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"ripple\",\n      \"ripple-surface\",\n      n && \"ripple-surface-unbound\",\n      R && `ripple-surface-${c}`,\n      e\n    ), D = () => {\n      if (v.find((L) => L === (c == null ? void 0 : c.toLowerCase())))\n        return N(!0);\n      {\n        const L = S(c).join(\",\");\n        return `radial-gradient(circle, ${g.split(\"{{color}}\").join(`${L}`)})`;\n      }\n    }, S = (w) => {\n      const L = ($) => ($.length < 7 && ($ = `#${$[1]}${$[1]}${$[2]}${$[2]}${$[3]}${$[3]}`), [parseInt($.substr(1, 2), 16), parseInt($.substr(3, 2), 16), parseInt($.substr(5, 2), 16)]), I = ($) => {\n        const C = document.body.appendChild(document.createElement(\"fictum\")), H = \"rgb(1, 2, 3)\";\n        return C.style.color = H, C.style.color !== H || (C.style.color = $, C.style.color === H || C.style.color === \"\") ? h : ($ = getComputedStyle(C).color, document.body.removeChild(C), $);\n      }, O = ($) => ($ = $.match(/[.\\d]+/g).map((C) => +Number(C)), $.length = 3, $);\n      return w.toLowerCase() === \"transparent\" ? h : w[0] === \"#\" ? L(w) : (w.indexOf(\"rgb\") === -1 && (w = I(w)), w.indexOf(\"rgb\") === 0 ? O(w) : h);\n    }, E = (w) => {\n      const { offsetX: L, offsetY: I, height: O, width: $ } = w, C = I <= O / 2, H = L <= $ / 2, P = (Y, Q) => Math.sqrt(Y ** 2 + Q ** 2), X = I === O / 2 && L === $ / 2, G = {\n        first: C === !0 && H === !1,\n        second: C === !0 && H === !0,\n        third: C === !1 && H === !0,\n        fourth: C === !1 && H === !1\n      }, _ = {\n        topLeft: P(L, I),\n        topRight: P($ - L, I),\n        bottomLeft: P(L, O - I),\n        bottomRight: P($ - L, O - I)\n      };\n      let J = 0;\n      return X || G.fourth ? J = _.topLeft : G.third ? J = _.topRight : G.second ? J = _.bottomRight : G.first && (J = _.bottomLeft), J * 2;\n    }, F = (w) => {\n      var J;\n      const L = (J = m.current) == null ? void 0 : J.getBoundingClientRect(), I = w.clientX - L.left, O = w.clientY - L.top, $ = L.height, C = L.width, H = {\n        offsetX: s ? $ / 2 : I,\n        offsetY: s ? C / 2 : O,\n        height: $,\n        width: C\n      }, P = {\n        delay: r && r * 0.5,\n        duration: r && r - r * 0.5\n      }, X = E(H), G = a || X / 2, _ = {\n        left: s ? `${C / 2 - G}px` : `${I - G}px`,\n        top: s ? `${$ / 2 - G}px` : `${O - G}px`,\n        height: a ? `${a * 2}px` : `${X}px`,\n        width: a ? `${a * 2}px` : `${X}px`,\n        transitionDelay: `0s, ${P.delay}ms`,\n        transitionDuration: `${r}ms, ${P.duration}ms`\n      };\n      return R ? _ : { ..._, backgroundImage: `${D()}` };\n    }, W = (w) => {\n      const L = F(w), I = b.concat(L);\n      T(I), i && i(w);\n    };\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      const w = setTimeout(() => {\n        b.length > 0 && T(b.splice(1, b.length - 1));\n      }, r);\n      return () => {\n        clearTimeout(w);\n      };\n    }, [r, b]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(t, { className: k, onMouseDown: (w) => W(w), ref: m, ...u, children: [\n      o,\n      b.map((w, L) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Le, { style: w }, L))\n    ] });\n  }\n);\nye.displayName = \"MDBRipple\";\nconst le = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    className: e,\n    color: t = \"primary\",\n    outline: s,\n    children: r,\n    rounded: n,\n    disabled: a,\n    floating: c,\n    size: o,\n    href: i,\n    block: u,\n    active: d,\n    toggle: p,\n    noRipple: m,\n    tag: g = \"button\",\n    role: h = \"button\",\n    ...v\n  }, b) => {\n    const [T, R] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(d || !1);\n    let N;\n    const k = t && [\"light\", \"link\"].includes(t) || s ? \"dark\" : \"light\";\n    t !== \"none\" ? s ? t ? N = `btn-outline-${t}` : N = \"btn-outline-primary\" : t ? N = `btn-${t}` : N = \"btn-primary\" : N = \"\";\n    const D = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      t !== \"none\" && \"btn\",\n      N,\n      n && \"btn-rounded\",\n      c && \"btn-floating\",\n      o && `btn-${o}`,\n      `${(i || g !== \"button\") && a ? \"disabled\" : \"\"}`,\n      u && \"btn-block\",\n      T && \"active\",\n      e\n    );\n    return i && g !== \"a\" && (g = \"a\"), [\"hr\", \"img\", \"input\"].includes(g) || m ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      g,\n      {\n        className: D,\n        onClick: p ? () => {\n          R(!T);\n        } : void 0,\n        disabled: a && g === \"button\" ? !0 : void 0,\n        href: i,\n        ref: b,\n        role: h,\n        ...v,\n        children: r\n      }\n    ) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      ye,\n      {\n        rippleTag: g,\n        rippleColor: k,\n        className: D,\n        onClick: p ? () => {\n          R(!T);\n        } : void 0,\n        disabled: a && g === \"button\" ? !0 : void 0,\n        href: i,\n        ref: b,\n        role: h,\n        ...v,\n        children: r\n      }\n    );\n  }\n);\nle.displayName = \"MDBBtn\";\nconst ke = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, shadow: s, toolbar: r, size: n, vertical: a, tag: c = \"div\", role: o = \"group\", ...i }, u) => {\n    let d;\n    r ? d = \"btn-toolbar\" : a ? d = \"btn-group-vertical\" : d = \"btn-group\";\n    const p = clsx__WEBPACK_IMPORTED_MODULE_2__(d, s && `shadow-${s}`, n && `btn-group-${n}`, e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(c, { className: p, ref: u, role: o, ...i, children: t });\n  }\n);\nke.displayName = \"MDBBtnGroup\";\nconst Se = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", color: r, grow: n, size: a, ...c }, o) => {\n    const i = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      `${n ? \"spinner-grow\" : \"spinner-border\"}`,\n      r && `text-${r}`,\n      `${a ? n ? \"spinner-grow-\" + a : \"spinner-border-\" + a : \"\"}`,\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: i, ref: o, ...c, children: t });\n  }\n);\nSe.displayName = \"MDBSpinner\";\nconst Ce = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, border: s, background: r, tag: n = \"div\", shadow: a, alignment: c, ...o }, i) => {\n    const u = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"card\",\n      s && `border border-${s}`,\n      r && `bg-${r}`,\n      a && `shadow-${a}`,\n      c && `text-${c}`,\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, { className: u, ref: i, ...o, children: t });\n  }\n);\nCe.displayName = \"MDBCard\";\nconst Ae = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, border: s, background: r, tag: n = \"div\", ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-header\", s && `border-${s}`, r && `bg-${r}`, e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, { className: o, ...a, ref: c, children: t });\n  }\n);\nAe.displayName = \"MDBCardHeader\";\nconst Pe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"p\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-subtitle\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nPe.displayName = \"MDBCardSubTitle\";\nconst Fe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"h5\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-title\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nFe.displayName = \"MDBCardTitle\";\nconst Oe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"p\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-text\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nOe.displayName = \"MDBCardText\";\nconst He = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-body\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nHe.displayName = \"MDBCardBody\";\nconst We = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, border: s, background: r, tag: n = \"div\", ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-footer\", s && `border-${s}`, r && `bg-${r}`, e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, { className: o, ...a, ref: c, children: t });\n  }\n);\nWe.displayName = \"MDBCardFooter\";\nconst Qt = ({ className: e, children: t, overlay: s, position: r, fluid: n, ...a }) => {\n  const c = clsx__WEBPACK_IMPORTED_MODULE_2__(r && `card-img-${r}`, n && \"img-fluid\", s && \"card-img\", e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", { className: c, ...a, children: t });\n}, Xe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-img-overlay\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nXe.displayName = \"MDBCardOverlay\";\nconst Zt = ({ className: e, children: t, ...s }) => {\n  const r = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-link\", e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", { className: r, ...s, children: t });\n}, _e = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"card-group\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\n_e.displayName = \"MDBCardGroup\";\nconst je = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, tag: t = \"ul\", horizontal: s, horizontalSize: r, light: n, numbered: a, children: c, small: o, ...i }, u) => {\n    const d = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"list-group\",\n      s && (r ? `list-group-horizontal-${r}` : \"list-group-horizontal\"),\n      n && \"list-group-light\",\n      a && \"list-group-numbered\",\n      o && \"list-group-small\",\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(t, { className: d, ref: u, ...i, children: c });\n  }\n);\nje.displayName = \"MDBListGroup\";\nconst Ge = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, tag: t = \"li\", active: s, disabled: r, action: n, color: a, children: c, noBorders: o, ...i }, u) => {\n    const d = t === \"button\", p = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"list-group-item\",\n      s && \"active\",\n      r && !d && \"disabled\",\n      n && \"list-group-item-action\",\n      a && `list-group-item-${a}`,\n      o && \"border-0\",\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(t, { className: p, disabled: d && r, ref: u, ...i, children: c });\n  }\n);\nGe.displayName = \"MDBListGroupItem\";\nconst zt = ({\n  className: e,\n  children: t,\n  disableMouseDown: s,\n  tag: r = le,\n  tooltipTag: n = \"div\",\n  options: a,\n  placement: c = \"top\",\n  title: o,\n  wrapperProps: i,\n  wrapperClass: u,\n  onOpen: d,\n  onClose: p,\n  onMouseEnter: m,\n  onMouseLeave: g,\n  ...h\n}) => {\n  const [v, b] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [T, R] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [N, k] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [D, S] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [E, F] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [W, w] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), L = clsx__WEBPACK_IMPORTED_MODULE_2__(\"tooltip\", E && \"show\", \"fade\", e), { styles: I, attributes: O } = (0,react_popper__WEBPACK_IMPORTED_MODULE_4__.usePopper)(v, T, {\n    placement: c,\n    ...a\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    let P, X;\n    return N || D ? (w(!0), P = setTimeout(() => {\n      F(!0);\n    }, 4)) : (F(!1), X = setTimeout(() => {\n      w(!1);\n    }, 300)), () => {\n      clearTimeout(P), clearTimeout(X);\n    };\n  }, [N, D]);\n  const $ = (P) => {\n    d == null || d(P), !P.defaultPrevented && k(!0), m == null || m(P);\n  }, C = (P) => {\n    p == null || p(P), !P.defaultPrevented && k(!1), g == null || g(P);\n  }, H = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (P) => {\n      P.target === v ? S(!0) : S(!1);\n    },\n    [v]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!s)\n      return document.addEventListener(\"mousedown\", H), () => {\n        document.removeEventListener(\"mousedown\", H);\n      };\n  }, [H, s]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      r,\n      {\n        className: u,\n        onMouseEnter: $,\n        onMouseLeave: C,\n        ref: b,\n        ...i,\n        children: t\n      }\n    ),\n    W && react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal(\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        n,\n        {\n          ref: R,\n          className: L,\n          style: I.popper,\n          ...O.popper,\n          role: \"tooltip\",\n          ...h,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"tooltip-inner\", children: o })\n        }\n      ),\n      document.body\n    )\n  ] });\n}, Ye = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    around: e,\n    between: t,\n    bottom: s,\n    center: r,\n    children: n,\n    className: a,\n    evenly: c,\n    end: o,\n    middle: i,\n    start: u,\n    tag: d = \"div\",\n    top: p,\n    ...m\n  }, g) => {\n    const h = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"row\",\n      e && \"justify-content-around\",\n      t && \"justify-content-between\",\n      s && \"align-self-end\",\n      r && \"justify-content-center\",\n      c && \"justifty-content-evenly\",\n      o && \"justify-content-end\",\n      i && \"align-self-center\",\n      u && \"justify-content-start\",\n      p && \"align-self-start\",\n      a\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(d, { className: h, ...m, ref: g, children: n });\n  }\n);\nYe.displayName = \"MDBRow\";\nconst es = ({\n  animate: e,\n  className: t,\n  icon: s,\n  fab: r,\n  fas: n,\n  fal: a,\n  far: c,\n  flag: o,\n  spin: i,\n  fixed: u,\n  flip: d,\n  list: p,\n  size: m,\n  pull: g,\n  pulse: h,\n  color: v,\n  border: b,\n  rotate: T,\n  inverse: R,\n  stack: N,\n  iconType: k,\n  children: D,\n  ...S\n}) => {\n  let E;\n  o ? E = \"flag\" : r ? E = \"fab\" : n ? E = \"fas\" : c ? E = \"far\" : a ? E = \"fal\" : E = \"fa\";\n  const F = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    k ? `fa-${k}` : E,\n    e && `fa-${e}`,\n    o ? `flag-${o}` : s && `fa-${s}`,\n    m && `fa-${m}`,\n    v && `text-${v}`,\n    b && \"fa-border\",\n    T && `fa-rotate-${T}`,\n    g && `fa-pull-${g}`,\n    i && !e && \"fa-spin\",\n    p && \"fa-li\",\n    u && \"fa-fw\",\n    h && !e && \"fa-pulse\",\n    R && \"fa-inverse\",\n    d && `fa-flip-${d}`,\n    N && `fa-stack-${N}`,\n    t\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"i\", { className: F, ...S, children: D });\n}, Ve = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    className: e,\n    children: t,\n    tag: s = \"p\",\n    variant: r,\n    color: n,\n    blockquote: a,\n    note: c,\n    noteColor: o,\n    listUnStyled: i,\n    listInLine: u,\n    ...d\n  }, p) => {\n    const m = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      r && r,\n      a && \"blockquote\",\n      c && \"note\",\n      n && `text-${n}`,\n      o && `note-${o}`,\n      i && \"list-unstyled\",\n      u && \"list-inline\",\n      e\n    );\n    return a && (s = \"blockquote\"), (i || u) && (s = \"ul\"), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: m, ref: p, ...d, children: t });\n  }\n);\nVe.displayName = \"MDBTypography\";\nconst qe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, color: t, uppercase: s, bold: r, children: n, ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"breadcrumb\",\n      r && \"font-weight-bold\",\n      t && `text-${t}`,\n      s && \"text-uppercase\",\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"nav\", { \"aria-label\": \"breadcrumb\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", { className: o, ref: c, ...a, children: n }) });\n  }\n);\nqe.displayName = \"MDBBreadcrumb\";\nconst Ke = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, active: t, current: s = \"page\", children: r, ...n }, a) => {\n    const c = clsx__WEBPACK_IMPORTED_MODULE_2__(\"breadcrumb-item\", t && \"active\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { className: c, ref: a, \"aria-current\": t && s, ...n, children: r });\n  }\n);\nKe.displayName = \"MDBBreadcrumbItem\";\nconst Ue = (e) => {\n  if (e !== !1)\n    return `navbar-expand-${e}`;\n}, Je = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    className: e,\n    children: t,\n    light: s,\n    dark: r,\n    scrolling: n,\n    fixed: a,\n    sticky: c,\n    scrollingNavbarOffset: o,\n    color: i,\n    transparent: u,\n    expand: d,\n    tag: p = \"nav\",\n    bgColor: m,\n    ...g\n  }, h) => {\n    const [v, b] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), T = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      {\n        \"navbar-light\": s,\n        \"navbar-dark\": r,\n        \"scrolling-navbar\": n || o,\n        \"top-nav-collapse\": v,\n        [`text-${i}`]: i && u ? v : i\n      },\n      a && `fixed-${a}`,\n      c && \"sticky-top\",\n      \"navbar\",\n      d && Ue(d),\n      m && `bg-${m}`,\n      e\n    ), R = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n      o && window.pageYOffset > o ? b(!0) : b(!1);\n    }, [o]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => ((n || o) && window.addEventListener(\"scroll\", R), () => {\n      window.removeEventListener(\"scroll\", R);\n    }), [R, n, o]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(p, { className: T, role: \"navigation\", ...g, ref: h, children: t });\n  }\n);\nJe.displayName = \"MDBNavbar\";\nconst Qe = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, className: t = \"\", disabled: s = !1, active: r = !1, tag: n = \"a\", ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"nav-link\", s ? \"disabled\" : r ? \"active\" : \"\", t);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, { \"data-test\": \"nav-link\", className: o, style: { cursor: \"pointer\" }, ref: c, ...a, children: e });\n  }\n);\nQe.displayName = \"MDBNavbarLink\";\nconst Ze = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"a\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"navbar-brand\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ref: n, ...r, children: t });\n  }\n);\nZe.displayName = \"MDBNavbarBrand\";\nconst ze = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, className: t, active: s, text: r, tag: n = \"li\", ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"nav-item\", s && \"active\", r && \"navbar-text\", t);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, { ...a, className: o, ref: c, children: e });\n  }\n);\nze.displayName = \"MDBNavbarItem\";\nconst et = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, className: t, right: s, fullWidth: r = !0, left: n, tag: a = \"ul\", ...c }, o) => {\n    const i = clsx__WEBPACK_IMPORTED_MODULE_2__(\"navbar-nav\", r && \"w-100\", s && \"ms-auto\", n && \"me-auto\", t);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { className: i, ref: o, ...c, children: e });\n  }\n);\net.displayName = \"MDBNavbarNav\";\nconst tt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, className: t, tag: s = \"button\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"navbar-toggler\", t);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { ...r, className: a, ref: n, children: e });\n  }\n);\ntt.displayName = \"MDBNavbarToggler\";\nconst st = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, bgColor: t, color: s, className: r, ...n }, a) => {\n    const c = clsx__WEBPACK_IMPORTED_MODULE_2__(t && `bg-${t}`, s && `text-${s}`, r);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"footer\", { className: c, ...n, ref: a, children: e });\n  }\n);\nst.displayName = \"MDBFooter\";\nconst rt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, size: t, circle: s, center: r, end: n, start: a, className: c, ...o }, i) => {\n    const u = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"pagination\",\n      r && \"justify-content-center\",\n      s && \"pagination-circle\",\n      n && \"justify-content-end\",\n      t && `pagination-${t}`,\n      a && \"justify-content-start\",\n      c\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { className: u, ...o, ref: i, children: e });\n  }\n);\nrt.displayName = \"MDBPagination\";\nconst nt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, className: t, tag: s = \"a\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"page-link\", t);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: e });\n  }\n);\nnt.displayName = \"MDBPaginationLink\";\nconst at = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ children: e, className: t, active: s, disabled: r, ...n }, a) => {\n    const c = clsx__WEBPACK_IMPORTED_MODULE_2__(\"page-item\", s && \"active\", r && \"disabled\", t);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { className: c, ...n, ref: a, children: e });\n  }\n);\nat.displayName = \"MDBPaginationItem\";\nconst ts = ({\n  className: e,\n  classNameResponsive: t,\n  responsive: s,\n  align: r,\n  borderColor: n,\n  bordered: a,\n  borderless: c,\n  children: o,\n  color: i,\n  hover: u,\n  small: d,\n  striped: p,\n  ...m\n}) => {\n  const g = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    \"table\",\n    r && `align-${r}`,\n    n && `border-${n}`,\n    a && \"table-bordered\",\n    c && \"table-borderless\",\n    i && `table-${i}`,\n    u && \"table-hover\",\n    d && \"table-sm\",\n    p && \"table-striped\",\n    e\n  ), h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"table\", { className: g, ...m, children: o }), [o, g, m]);\n  if (s) {\n    const v = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      typeof s == \"string\" ? `table-responsive-${s}` : \"table-responsive\",\n      t\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: v, children: h });\n  } else\n    return h;\n}, ss = ({ className: e, children: t, dark: s, light: r, ...n }) => {\n  const a = clsx__WEBPACK_IMPORTED_MODULE_2__(s && \"table-dark\", r && \"table-light\", e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"thead\", { className: a, ...n, children: t });\n}, rs = ({ className: e, children: t, ...s }) => {\n  const r = clsx__WEBPACK_IMPORTED_MODULE_2__(e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"tbody\", { className: r, ...s, children: t });\n}, Ne = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    animated: e,\n    children: t,\n    className: s,\n    style: r,\n    tag: n = \"div\",\n    valuenow: a,\n    valuemax: c,\n    striped: o,\n    bgColor: i,\n    valuemin: u,\n    width: d,\n    ...p\n  }, m) => {\n    const g = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"progress-bar\",\n      i && `bg-${i}`,\n      o && \"progress-bar-striped\",\n      e && \"progress-bar-animated\",\n      s\n    ), h = { width: `${d}%`, ...r };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      n,\n      {\n        className: g,\n        style: h,\n        ref: m,\n        role: \"progressbar\",\n        ...p,\n        \"aria-valuenow\": Number(d) ?? a,\n        \"aria-valuemin\": Number(u),\n        \"aria-valuemax\": Number(c),\n        children: t\n      }\n    );\n  }\n);\nNe.displayName = \"MDBProgressBar\";\nconst ot = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", height: r, style: n, ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"progress\", e), i = { height: `${r}px`, ...n };\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: o, ref: c, style: i, ...a, children: react__WEBPACK_IMPORTED_MODULE_1__.Children.map(t, (u) => {\n      if (!react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(u) || u.type !== Ne) {\n        console.error(\"Progress component only allows ProgressBar as child\");\n        return;\n      } else\n        return u;\n    }) });\n  }\n);\not.displayName = \"MDBProgress\";\nconst ct = (e) => {\n  const [t, s] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), r = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => new IntersectionObserver(([n]) => {\n    s(n.isIntersecting);\n  }), []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (e.current)\n      return r.observe(e.current), () => r.disconnect();\n  }, [r, e]), t;\n}, lt = (e, t) => (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => t !== void 0 ? t : e, [t, e]), it = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    className: e,\n    size: t,\n    contrast: s,\n    value: r,\n    defaultValue: n,\n    id: a,\n    labelClass: c,\n    wrapperClass: o,\n    wrapperStyle: i,\n    wrapperTag: u = \"div\",\n    label: d,\n    onChange: p,\n    children: m,\n    labelRef: g,\n    labelStyle: h,\n    type: v,\n    onBlur: b,\n    readonly: T = !1,\n    showCounter: R = !1,\n    ...N\n  }, k) => {\n    var Q, Z;\n    const [D, S] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(r || n), [E, F] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), [W, w] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [L, I] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), O = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), $ = ct(O);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(k, () => O.current);\n    const C = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), H = g || C, P = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-outline\", s && \"form-white\", o), X = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"form-control\",\n      W && \"active\",\n      v === \"date\" && \"active\",\n      t && `form-control-${t}`,\n      e\n    ), G = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-label\", c);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      if (!O.current)\n        return;\n      const { value: M } = O.current;\n      M != \"\" ? w(!0) : w(!1);\n    }, [(Q = O.current) == null ? void 0 : Q.value]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      r !== void 0 && (r != \"\" ? w(!0) : w(!1));\n    }, [r]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      n !== void 0 && (n != \"\" ? w(!0) : w(!1));\n    }, [n]);\n    const _ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n      var M;\n      (M = H.current) != null && M.clientWidth && F(H.current.clientWidth * 0.8 + 8);\n    }, [H]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      _();\n    }, [(Z = H.current) == null ? void 0 : Z.clientWidth, _, $]);\n    const J = (M) => {\n      S(M.target.value), R && I(M.target.value.length), p == null || p(M);\n    }, Y = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n      (M) => {\n        O.current && (D !== void 0 && D != \"\" || r !== void 0 && r != \"\" || O.current.value != \"\" ? w(!0) : w(!1), b && b(M));\n      },\n      [D, r, b]\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(u, { className: P, style: i, children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        \"input\",\n        {\n          type: v,\n          readOnly: T,\n          className: X,\n          onBlur: Y,\n          onChange: J,\n          onFocus: _,\n          value: r,\n          defaultValue: n,\n          id: a,\n          ref: O,\n          ...N\n        }\n      ),\n      d && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"label\", { className: G, style: h, htmlFor: a, ref: H, children: d }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { className: \"form-notch\", children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-notch-leading\" }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-notch-middle\", style: { width: E } }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-notch-trailing\" })\n      ] }),\n      m,\n      R && N.maxLength && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-helper\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-counter\", children: `${L}/${N.maxLength}` }) })\n    ] });\n  }\n);\nit.displayName = \"MDBInput\";\nconst ue = ({\n  className: e,\n  inputRef: t,\n  labelClass: s,\n  wrapperClass: r,\n  labelStyle: n,\n  wrapperTag: a = \"div\",\n  wrapperStyle: c,\n  label: o,\n  inline: i,\n  btn: u,\n  id: d,\n  btnColor: p,\n  disableWrapper: m,\n  toggleSwitch: g,\n  ...h\n}) => {\n  let v = \"form-check-input\", b = \"form-check-label\";\n  u && (v = \"btn-check\", p ? b = `btn btn-${p}` : b = \"btn btn-primary\");\n  const T = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    o && !u && \"form-check\",\n    i && !u && \"form-check-inline\",\n    g && \"form-switch\",\n    r\n  ), R = clsx__WEBPACK_IMPORTED_MODULE_2__(v, e), N = clsx__WEBPACK_IMPORTED_MODULE_2__(b, s), k = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", { className: R, id: d, ref: t, ...h }),\n    o && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"label\", { className: N, style: n, htmlFor: d, children: o })\n  ] });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: m ? k : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { style: c, className: T, children: k }) });\n}, ns = ({ ...e }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ue, { type: \"checkbox\", ...e }), as = ({ ...e }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ue, { type: \"radio\", ...e }), dt = ({\n  className: e,\n  children: t,\n  open: s = !1,\n  id: r,\n  navbar: n,\n  tag: a = \"div\",\n  collapseRef: c,\n  style: o,\n  onOpen: i,\n  onClose: u,\n  ...d\n}) => {\n  const [p, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [g, h] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(void 0), [v, b] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), T = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    v ? \"collapsing\" : \"collapse\",\n    !v && p && \"show\",\n    n && \"navbar-collapse\",\n    e\n  ), R = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), N = c ?? R, k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    p && h(void 0);\n  }, [p]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var D;\n    g === void 0 && p && h((D = N == null ? void 0 : N.current) == null ? void 0 : D.scrollHeight);\n  }, [g, p, N]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    p !== s && (s ? i == null || i() : u == null || u(), m(s)), p && b(!0);\n    const D = setTimeout(() => {\n      b(!1);\n    }, 350);\n    return () => {\n      clearTimeout(D);\n    };\n  }, [s, p, i, u]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var D;\n    h(p ? (D = N == null ? void 0 : N.current) == null ? void 0 : D.scrollHeight : 0);\n  }, [p, N, t]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (window.addEventListener(\"resize\", k), () => {\n    window.removeEventListener(\"resize\", k);\n  }), [k]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { style: { height: g, ...o }, id: r, className: T, ...d, ref: N, children: t });\n}, we = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null), ut = ({\n  children: e,\n  isOpen: t = !1,\n  options: s,\n  animation: r = !0,\n  dropup: n,\n  dropright: a,\n  dropleft: c,\n  onClose: o,\n  onOpen: i\n}) => {\n  const [u, d] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(t), [p, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [g, h] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [v, b] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(-1);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    we.Provider,\n    {\n      value: {\n        animation: r,\n        activeIndex: v,\n        isOpenState: u,\n        setReferenceElement: m,\n        setPopperElement: h,\n        setActiveIndex: b,\n        popperElement: g,\n        setIsOpenState: d,\n        referenceElement: p,\n        onClose: o,\n        onOpen: i,\n        dropup: n,\n        options: s,\n        dropright: a,\n        dropleft: c\n      },\n      children: e\n    }\n  );\n}, mt = (e) => e instanceof HTMLElement, ft = (e) => e instanceof Node, re = () => {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(we);\n  if (!e)\n    throw new Error(\"Missing context data\");\n  return e;\n}, pt = () => {\n  const { isOpenState: e, setIsOpenState: t, setActiveIndex: s, popperElement: r, referenceElement: n, onClose: a } = re(), c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (o) => {\n      e && (a == null || a(o)), !(!e || !ft(o.target) || r && r.contains(o.target) || n && n.contains(o.target) || o.defaultPrevented) && (t(!1), setTimeout(() => s(-1), 300));\n    },\n    [e, t, s, r, n, a]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (document.addEventListener(\"mousedown\", c), () => document.removeEventListener(\"mousedown\", c)), [c]);\n}, gt = ({\n  className: e,\n  tag: t = \"div\",\n  group: s,\n  children: r,\n  dropup: n,\n  dropright: a,\n  dropleft: c,\n  ...o\n}) => {\n  pt();\n  const i = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    s ? \"btn-group\" : \"dropdown\",\n    n && \"dropup\",\n    a && \"dropend\",\n    c && \"dropstart\",\n    e\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(t, { className: i, ...o, children: r });\n}, os = ({ animation: e, onClose: t, onOpen: s, ...r }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ut, { animation: e, onClose: t, onOpen: s, ...r, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(gt, { ...r }) }), ht = ({\n  childTag: e,\n  children: t,\n  disabled: s,\n  link: r,\n  divider: n,\n  header: a,\n  href: c = \"#\"\n}) => {\n  const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"dropdown-item\", s && \"disabled\");\n  return r ? e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { className: o, children: t }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", { href: c, className: o, children: t }) : n ? e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { className: \"dropdown-divider\", children: t }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"hr\", { className: \"dropdown-divider\" }) : a ? e ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(e, { className: \"dropdown-header\", children: t }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", { className: \"dropdown-header\", children: t }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: t });\n};\nconst cs = ({\n  onClick: e,\n  tag: t = \"li\",\n  childTag: s,\n  children: r,\n  style: n,\n  link: a,\n  divider: c,\n  header: o,\n  disabled: i,\n  href: u,\n  preventCloseOnClick: d,\n  ...p\n}) => {\n  const { setIsOpenState: m, onClose: g, setActiveIndex: h } = re();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(t, { style: n, onClick: (b) => {\n    g == null || g(b), e == null || e(b), !(i || d || b.defaultPrevented) && (setTimeout(() => h(-1), 300), m(!1));\n  }, ...p, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    ht,\n    {\n      link: a,\n      divider: c,\n      header: o,\n      disabled: i,\n      href: u,\n      childTag: s,\n      children: r\n    }\n  ) });\n}, ge = (e, t, s) => s === \"up\" ? e <= 0 ? t[t.length - 1].props.divider === !0 || t[t.length - 1].props.disabled === !0 : t[e - 1].props.divider === !0 || t[e - 1].props.disabled === !0 : e === t.length - 1 ? t[0].props.divider === !0 || t[0].props.disabled === !0 : t[e + 1].props.divider === !0 || t[e + 1].props.disabled === !0, bt = (e) => {\n  const { activeIndex: t, isOpenState: s, setIsOpenState: r, setActiveIndex: n, onClose: a } = re(), c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (o) => {\n      const i = [\"ArrowUp\", \"ArrowDown\", \"Tab\", \"Enter\", \"Escape\"];\n      if (!(!Array.isArray(e) || !i.includes(o.key))) {\n        if (mt(document.activeElement) && document.activeElement.blur(), o.key === \"ArrowUp\") {\n          o.preventDefault();\n          const u = ge(t, e, \"up\");\n          if (t === 1) {\n            n(u ? e.length - 1 : 0);\n            return;\n          }\n          if (t <= 0) {\n            n(u ? e.length - 2 : e.length - 1);\n            return;\n          }\n          n((d) => u ? d - 2 : d - 1);\n        }\n        if (o.key === \"ArrowDown\" || o.key === \"Tab\") {\n          o.preventDefault();\n          const u = ge(t, e, \"down\");\n          if (t === e.length - 2) {\n            n((d) => u ? 0 : d + 1);\n            return;\n          }\n          if (t === e.length - 1) {\n            n(u ? 1 : 0);\n            return;\n          }\n          n((d) => u ? d + 2 : d + 1);\n        }\n        if (o.key === \"Enter\") {\n          const u = document.querySelector('[data-active=\"true\"]'), d = u == null ? void 0 : u.firstElementChild;\n          if (d)\n            return d.click();\n          if (a == null || a(o), o.defaultPrevented)\n            return;\n          r(!1), setTimeout(() => n(-1), 300);\n        }\n        if (o.key === \"Escape\") {\n          if (a == null || a(o), o.defaultPrevented)\n            return;\n          r(!1), setTimeout(() => n(-1), 300);\n        }\n      }\n    },\n    [e, r, n, t, a]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (s && document.addEventListener(\"keydown\", c), () => {\n    s && document.removeEventListener(\"keydown\", c);\n  }), [s, c]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const o = document.querySelector('[data-active=\"true\"]'), i = o == null ? void 0 : o.firstElementChild;\n    return i == null || i.focus(), () => i == null ? void 0 : i.blur();\n  }, [t]);\n}, vt = () => {\n  const { isOpenState: e } = re(), [t, s] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [r, n] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [a, c] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(e);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    let o;\n    return e || (n(!0), s(!1), o = setTimeout(() => {\n      n(!1), c(!1);\n    }, 300)), e && (s(!0), n(!1), c(!0), o = setTimeout(() => {\n      s(!1);\n    }, 300)), () => clearTimeout(o);\n  }, [e]), { open: a, isFadeIn: t, isFadeOut: r };\n};\nconst ls = ({\n  className: e,\n  tag: t = \"ul\",\n  children: s,\n  style: r,\n  dark: n,\n  responsive: a = \"\",\n  appendToBody: c = !1,\n  alwaysOpen: o,\n  ...i\n}) => {\n  const {\n    activeIndex: u,\n    setPopperElement: d,\n    isOpenState: p,\n    animation: m,\n    referenceElement: g,\n    popperElement: h,\n    options: v,\n    dropleft: b,\n    dropup: T,\n    dropright: R\n  } = re(), { open: N, isFadeIn: k, isFadeOut: D } = vt();\n  bt(s);\n  const S = () => {\n    if (R)\n      return \"right-start\";\n    if (b)\n      return \"left-start\";\n    const w = h && getComputedStyle(h).getPropertyValue(\"--mdb-position\").trim() === \"end\";\n    return T ? w ? \"top-end\" : \"top-start\" : w ? \"bottom-end\" : \"bottom-start\";\n  }, { styles: E } = (0,react_popper__WEBPACK_IMPORTED_MODULE_4__.usePopper)(g, h, {\n    placement: S(),\n    modifiers: [_popperjs_core__WEBPACK_IMPORTED_MODULE_5__.flip],\n    ...v\n  }), F = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    \"dropdown-menu\",\n    n && \"dropdown-menu-dark\",\n    p && \"show\",\n    m && \"animation\",\n    k && \"fade-in\",\n    D && \"fade-out\",\n    a && `dropdown-menu-${a}`,\n    e\n  );\n  if (!N && !o)\n    return null;\n  const W = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    t,\n    {\n      className: F,\n      style: { position: \"absolute\", zIndex: 1e3, ...E.popper, ...r },\n      ref: d,\n      ...i,\n      children: react__WEBPACK_IMPORTED_MODULE_1__.Children.map(\n        s,\n        (w, L) => (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(w, {\n          tabIndex: 1,\n          \"data-active\": u === L && !0,\n          className: clsx__WEBPACK_IMPORTED_MODULE_2__(u === L ? \"active\" : \"\", w.props.className)\n        })\n      )\n    }\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: c ? (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(W, document.body) : W });\n}, is = ({\n  className: e,\n  tag: t = le,\n  children: s,\n  onClick: r,\n  split: n,\n  ...a\n}) => {\n  const { setIsOpenState: c, setReferenceElement: o, isOpenState: i, setActiveIndex: u, onClose: d, onOpen: p } = re(), m = clsx__WEBPACK_IMPORTED_MODULE_2__(\"dropdown-toggle\", n && \"dropdown-toggle-split\", e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    t,\n    {\n      onClick: (h) => {\n        r == null || r(h), i ? d == null || d(h) : p == null || p(h), !h.defaultPrevented && (c((v) => !v), setTimeout(() => u(-1), 300));\n      },\n      ref: o,\n      className: m,\n      \"aria-expanded\": !!i,\n      ...a,\n      children: s\n    }\n  );\n}, ds = ({\n  className: e,\n  btnClassName: t,\n  btnChildren: s,\n  children: r,\n  tag: n = le,\n  onOpen: a,\n  onClose: c,\n  popperTag: o = \"div\",\n  open: i,\n  placement: u = \"bottom\",\n  dismiss: d,\n  options: p,\n  poperStyle: m,\n  onClick: g,\n  ...h\n}) => {\n  const [v, b] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), [T, R] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(), { styles: N, attributes: k } = (0,react_popper__WEBPACK_IMPORTED_MODULE_4__.usePopper)(v, T, { placement: u, ...p }), [D, S] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(i ?? !1), E = lt(D, i), [F, W] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [w, L] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), I = clsx__WEBPACK_IMPORTED_MODULE_2__(\"popover fade\", F && E && \"show\", e), O = (C) => {\n    E && !d ? c == null || c() : E || a == null || a(), d ? (L(!0), S(!0)) : S(!E), g && g(C);\n  }, $ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (C) => {\n      w && T && E && v && !v.contains(C.target) && (S(!1), c == null || c());\n    },\n    [w, E, T, v, c]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const C = setTimeout(() => {\n      W(E);\n    }, 150);\n    return () => {\n      clearTimeout(C);\n    };\n  }, [E]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (E && document.addEventListener(\"mousedown\", $), () => {\n    document.removeEventListener(\"mousedown\", $);\n  }), [$, E]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(n, { onClick: O, className: t, ...h, ref: b, children: s }),\n    (F || E) && react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal(\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        o,\n        {\n          className: I,\n          ref: R,\n          style: { ...N.popper, ...m },\n          ...k.popper,\n          children: r\n        }\n      ),\n      document.body\n    )\n  ] });\n}, us = ({\n  className: e,\n  children: t,\n  tag: s = \"div\",\n  ...r\n}) => {\n  const n = clsx__WEBPACK_IMPORTED_MODULE_2__(\"popover-body\", e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: n, ...r, children: t });\n}, ms = ({\n  className: e,\n  children: t,\n  tag: s = \"h3\",\n  ...r\n}) => {\n  const n = clsx__WEBPACK_IMPORTED_MODULE_2__(\"popover-header\", e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: n, ...r, children: t });\n}, fs = ({\n  animationDirection: e,\n  appendToBody: t,\n  backdrop: s = !0,\n  children: r,\n  className: n,\n  closeOnEsc: a = !0,\n  setOpen: c,\n  leaveHiddenModal: o = !0,\n  modalRef: i,\n  onClose: u,\n  onClosePrevented: d,\n  onOpen: p,\n  open: m,\n  staticBackdrop: g,\n  nonInvasive: h = !1,\n  tag: v = \"div\",\n  ...b\n}) => {\n  const [T, R] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(m), [N, k] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(m), [D, S] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(m), [E, F] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [W, w] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), [L, I] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]), O = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), $ = i || O, C = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    \"modal\",\n    E && \"modal-static\",\n    e,\n    \"fade\",\n    N && \"show\",\n    T && h && \"modal-non-invasive-show\",\n    n\n  ), H = clsx__WEBPACK_IMPORTED_MODULE_2__(\"modal-backdrop\", \"fade\", T && \"show\"), P = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    k((Y) => (Y && (u == null || u()), !1)), setTimeout(() => {\n      R(!1), c == null || c(!1);\n    }, 150), setTimeout(() => {\n      S(!1);\n    }, 350);\n  }, [u, c]), X = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (Y) => {\n      h || N && Y.target === $.current && (g ? (F(!0), d == null || d(), setTimeout(() => {\n        F(!1);\n      }, 300)) : P());\n    },\n    [N, $, g, P, d, h]\n  ), G = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (Y) => {\n      N && Y.key === \"Tab\" && (Y.preventDefault(), w(W + 1)), a && N && Y.key === \"Escape\" && (g ? (F(!0), d == null || d(), setTimeout(() => {\n        F(!1);\n      }, 300)) : P());\n    },\n    [N, a, W, g, P, d]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var Z;\n    const Y = (Z = $.current) == null ? void 0 : Z.querySelectorAll(\n      \"button, a, input, select, textarea, [tabindex]\"\n    ), Q = Array.from(Y).filter((M) => M.tabIndex !== -1).sort((M, A) => M.tabIndex === A.tabIndex ? 0 : A.tabIndex === null ? -1 : M.tabIndex === null ? 1 : M.tabIndex - A.tabIndex);\n    I(Q), w(Q.length - 1);\n  }, [$]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    L && L.length > 0 && (W === L.length ? (L[0].focus(), w(0)) : L[W].focus());\n  }, [W, L]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const Y = () => {\n      const Z = document.documentElement.clientWidth;\n      return Math.abs(window.innerWidth - Z);\n    }, Q = window.innerWidth > document.documentElement.clientWidth && window.innerWidth >= 576;\n    if (D && Q && !h) {\n      const Z = Y();\n      document.body.classList.add(\"modal-open\"), document.body.style.overflow = \"hidden\", document.body.style.paddingRight = `${Z}px`;\n    } else\n      document.body.classList.remove(\"modal-open\"), document.body.style.overflow = \"\", document.body.style.paddingRight = \"\";\n    return () => {\n      document.body.classList.remove(\"modal-open\"), document.body.style.overflow = \"\", document.body.style.paddingRight = \"\";\n    };\n  }, [D, h]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    m ? (p == null || p(), S(!0), setTimeout(() => {\n      R(!0);\n    }, 0), setTimeout(() => {\n      k(!0), c == null || c(!0);\n    }, 150)) : P();\n  }, [m, P, c, p]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const Y = (Q) => {\n      Q.target.closest(\".modal-dialog\") || window.addEventListener(\"mouseup\", X, { once: !0 });\n    };\n    return window.addEventListener(\"mousedown\", Y), window.addEventListener(\"keydown\", G), () => {\n      window.removeEventListener(\"mousedown\", Y), window.removeEventListener(\"keydown\", G);\n    };\n  }, [G, X]);\n  const _ = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: (o || m || D) && react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal(\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        v,\n        {\n          className: C,\n          ref: $,\n          style: { display: D || m ? \"block\" : \"none\", pointerEvents: h ? \"none\" : \"initial\" },\n          ...b,\n          children: r\n        }\n      ),\n      react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal(\n        s && D && !h && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: H }),\n        document.body\n      )\n    ] }),\n    document.body\n  ) }), J = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: (o || m || D) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      v,\n      {\n        className: C,\n        ref: $,\n        style: { display: D || m ? \"block\" : \"none\", pointerEvents: h ? \"none\" : \"initial\" },\n        ...b,\n        children: r\n      }\n    ),\n    react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal(\n      s && D && !h && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { onClick: P, className: H }),\n      document.body\n    )\n  ] }) });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: t ? _ : J });\n}, yt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, centered: t, children: s, size: r, scrollable: n, tag: a = \"div\", ...c }, o) => {\n    const i = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"modal-dialog\",\n      n && \"modal-dialog-scrollable\",\n      t && \"modal-dialog-centered\",\n      r && `modal-${r}`,\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { className: i, ...c, ref: o, children: s });\n  }\n);\nyt.displayName = \"MDBModalDialog\";\nconst Nt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"modal-content\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nNt.displayName = \"MDBModalContent\";\nconst wt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"modal-header\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nwt.displayName = \"MDBModalHeader\";\nconst Bt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"h5\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"modal-title\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nBt.displayName = \"MDBModalTitle\";\nconst Mt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"modal-body\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nMt.displayName = \"MDBModalBody\";\nconst Dt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, tag: s = \"div\", ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"modal-footer\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(s, { className: a, ...r, ref: n, children: t });\n  }\n);\nDt.displayName = \"MDBModalFooter\";\nconst me = react__WEBPACK_IMPORTED_MODULE_1__.createContext({\n  activeElement: null,\n  setTargets: null\n}), ps = ({\n  container: e = typeof window !== void 0 ? window : null,\n  className: t,\n  children: s,\n  offset: r = 10,\n  ...n\n}) => {\n  const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"sticky-top\", t), [c, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [i, u] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]), d = e instanceof Window, p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    var T, R, N;\n    if (!i.length)\n      return;\n    const m = d ? window.pageYOffset : (T = e == null ? void 0 : e.current) == null ? void 0 : T.scrollTop, g = Number(r), h = (R = i[i.length - 1]) == null ? void 0 : R.current, v = (N = i[0]) == null ? void 0 : N.current;\n    m + g < v.offsetTop && o(null), i.forEach((k, D) => {\n      var W;\n      const S = (W = i[D + 1]) == null ? void 0 : W.current, E = k.current;\n      if (m > E.offsetTop - g && m < (S == null ? void 0 : S.offsetTop) - g) {\n        o(E);\n        return;\n      }\n    }), m > h.offsetTop - g && o(h);\n  }, [r, i, d, e]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const m = d ? e : e == null ? void 0 : e.current;\n    return p(), m == null || m.addEventListener(\"scroll\", p), () => {\n      m == null || m.removeEventListener(\"scroll\", p);\n    };\n  }, [p, e, d]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: a, ...n, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { className: \"nav flex-column nav-pills menu-sidebar\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(me.Provider, { value: { activeElement: c, setTargets: u }, children: s }) }) });\n}, gs = ({\n  className: e,\n  collapsible: t,\n  targetRef: s,\n  children: r,\n  subsections: n,\n  onClick: a,\n  onActivate: c,\n  ...o\n}) => {\n  var v;\n  const { activeElement: i, setTargets: u } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(me), d = () => n == null ? void 0 : n.some((b) => b.current.id === (i == null ? void 0 : i.id)), p = (i == null ? void 0 : i.id) === ((v = s.current) == null ? void 0 : v.id), m = p || d();\n  p && (c == null || c(i == null ? void 0 : i.id));\n  const g = clsx__WEBPACK_IMPORTED_MODULE_2__(\"nav-link\", t && \"collapsible-scrollspy\", m && \"active\", e), h = (b) => {\n    const T = s == null ? void 0 : s.current;\n    T == null || T.scrollIntoView({ behavior: \"smooth\" }), a == null || a(b);\n  };\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    u((b) => [...b, s]);\n  }, [u, s]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { className: \"nav-item\", style: { cursor: \"pointer\" }, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", { className: g, onClick: h, ...o, children: r }) });\n}, hs = ({\n  collapsible: e,\n  className: t,\n  children: s,\n  style: r,\n  ...n\n}) => {\n  const [a, c] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"0px\"), { activeElement: o } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(me), i = clsx__WEBPACK_IMPORTED_MODULE_2__(\"nav flex-column\", t), u = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const p = () => e == null ? void 0 : e.some((g) => g.current.id === (o == null ? void 0 : o.id)), m = u.current;\n    p() ? c(`${m == null ? void 0 : m.scrollHeight}px`) : c(\"0px\");\n  }, [o, e]);\n  const d = {\n    overflow: \"hidden\",\n    height: a,\n    transition: \"height .5s ease\",\n    flexWrap: \"nowrap\",\n    ...r\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { className: i, ref: u, style: e ? d : r, ...n, children: s });\n}, bs = ({ ...e }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ue, { type: \"checkbox\", toggleSwitch: !0, ...e }), Tt = ({ value: e, min: t = \"0\", max: s = \"100\", showThumb: r }) => {\n  const n = Number(e), [a, c] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n    (n || 0 - Number(t)) * 100 / (Number(s) - Number(t))\n  ), o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"thumb\", r && \"thumb-active\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    c((Number(e) - Number(t)) * 100 / (Number(s) - Number(t)));\n  }, [e, s, t]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: o, style: { left: `calc(${a}% + (${8 - a * 0.15}px))` }, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: \"thumb-value\", children: e }) });\n}, vs = ({\n  className: e,\n  defaultValue: t = 0,\n  disableTooltip: s,\n  labelId: r,\n  max: n,\n  min: a,\n  onMouseDown: c,\n  onMouseUp: o,\n  onTouchStart: i,\n  onTouchEnd: u,\n  onChange: d,\n  labelClass: p,\n  value: m,\n  label: g,\n  id: h,\n  inputRef: v,\n  ...b\n}) => {\n  const [T, R] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(t), [N, k] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), D = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-range\", e), S = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-label\", p);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    g && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"label\", { className: S, id: r, htmlFor: h, children: g }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { className: \"range\", children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        \"input\",\n        {\n          type: \"range\",\n          onMouseDown: (I) => {\n            k(!0), c && c(I);\n          },\n          onMouseUp: (I) => {\n            k(!1), o && o(I);\n          },\n          onTouchStart: (I) => {\n            k(!0), i && i(I);\n          },\n          onTouchEnd: (I) => {\n            k(!1), u && u(I);\n          },\n          onChange: (I) => {\n            R(I.target.value), d && d(I);\n          },\n          className: D,\n          value: m || T,\n          id: h,\n          min: a,\n          max: n,\n          ref: v,\n          ...b\n        }\n      ),\n      !s && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Tt, { value: m || T, showThumb: N, min: a, max: n })\n    ] })\n  ] });\n}, ys = ({ className: e, labelClass: t, labelStyle: s, inputRef: r, size: n, label: a, id: c, ...o }) => {\n  const i = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-control\", `form-control-${n}`, e), u = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-label\", t);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n    a && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"label\", { className: u, style: s, htmlFor: c, children: a }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", { className: i, type: \"file\", id: c, ref: r, ...o })\n  ] });\n}, Rt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    className: e,\n    children: t,\n    noBorder: s,\n    textBefore: r,\n    textAfter: n,\n    noWrap: a,\n    tag: c = \"div\",\n    textTag: o = \"span\",\n    textClass: i,\n    size: u,\n    textProps: d,\n    ...p\n  }, m) => {\n    const g = clsx__WEBPACK_IMPORTED_MODULE_2__(\"input-group\", a && \"flex-nowrap\", u && `input-group-${u}`, e), h = clsx__WEBPACK_IMPORTED_MODULE_2__(\"input-group-text\", s && \"border-0\", i), v = (b) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: b && Array.isArray(b) ? b.map((T, R) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { className: h, ...d, children: T }, R)) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(o, { className: h, ...d, children: b }) });\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(c, { className: g, ref: m, ...p, children: [\n      r && v(r),\n      t,\n      n && v(n)\n    ] });\n  }\n);\nRt.displayName = \"MDBInputGroup\";\nconst $t = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, isValidated: s = !1, onReset: r, onSubmit: n, noValidate: a = !0, ...c }, o) => {\n    const [i, u] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(s), d = clsx__WEBPACK_IMPORTED_MODULE_2__(\"needs-validation\", i && \"was-validated\", e), p = (g) => {\n      g.preventDefault(), u(!0), n && n(g);\n    }, m = (g) => {\n      g.preventDefault(), u(!1), r && r(g);\n    };\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      u(s);\n    }, [s]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      \"form\",\n      {\n        className: d,\n        onSubmit: p,\n        onReset: m,\n        ref: o,\n        noValidate: a,\n        ...c,\n        children: t\n      }\n    );\n  }\n);\n$t.displayName = \"MDBValidation\";\nconst Et = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, fill: t, pills: s, justify: r, children: n, ...a }, c) => {\n    const o = clsx__WEBPACK_IMPORTED_MODULE_2__(\n      \"nav\",\n      s ? \"nav-pills\" : \"nav-tabs\",\n      t && \"nav-fill\",\n      r && \"nav-justified\",\n      e\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { className: o, ref: c, ...a, children: n });\n  }\n);\nEt.displayName = \"MDBTabs\";\nconst It = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, children: t, style: s, tag: r = \"li\", ...n }, a) => {\n    const c = clsx__WEBPACK_IMPORTED_MODULE_2__(\"nav-item\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(r, { className: c, style: { cursor: \"pointer\", ...s }, role: \"presentation\", ref: a, ...n, children: t });\n  }\n);\nIt.displayName = \"MDBTabsItem\";\nconst Lt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, color: t, active: s, onOpen: r, onClose: n, children: a, ...c }, o) => {\n    const i = clsx__WEBPACK_IMPORTED_MODULE_2__(\"nav-link\", s && \"active\", t && `bg-${t}`, e);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      s ? r == null || r() : n == null || n();\n    }, [s]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", { className: i, ref: o, ...c, children: a });\n  }\n);\nLt.displayName = \"MDBTabsLink\";\nconst xt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, tag: t = \"div\", children: s, ...r }, n) => {\n    const a = clsx__WEBPACK_IMPORTED_MODULE_2__(\"tab-content\", e);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(t, { className: a, ref: n, ...r, children: s });\n  }\n);\nxt.displayName = \"MDBTabsContent\";\nconst kt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({ className: e, tag: t = \"div\", open: s, children: r, ...n }, a) => {\n    const [c, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), i = clsx__WEBPACK_IMPORTED_MODULE_2__(\"tab-pane\", \"fade\", c && \"show\", s && \"active\", e);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      let u;\n      return s ? u = setTimeout(() => {\n        o(!0);\n      }, 100) : o(!1), () => {\n        clearTimeout(u);\n      };\n    }, [s]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(t, { className: i, role: \"tabpanel\", ref: a, ...n, children: r });\n  }\n);\nkt.displayName = \"MDBTabsPane\";\nconst fe = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n  active: 0\n}), St = ({ imagesCount: e, to: t }) => {\n  const { active: s } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(fe);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", { className: \"carousel-indicators\", children: Array.from(Array(e)).map((r, n) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { \"data-mdb-target\": n, className: clsx__WEBPACK_IMPORTED_MODULE_2__(s === n && \"active\"), onClick: () => t(n) }, n)) });\n}, Ct = ({ move: e }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"a\", { role: \"button\", className: \"carousel-control-prev\", onClick: () => e(\"prev\"), children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: \"carousel-control-prev-icon\" }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: \"visually-hidden\", children: \"Previous\" })\n  ] }),\n  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"a\", { role: \"button\", className: \"carousel-control-next\", onClick: () => e(\"next\"), children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: \"carousel-control-next-icon\" }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: \"visually-hidden\", children: \"Next\" })\n  ] })\n] }), At = (e) => {\n  const t = getComputedStyle(e), s = getComputedStyle(e == null ? void 0 : e.parentNode);\n  return t.display !== \"none\" && s.display !== \"none\" && t.visibility !== \"hidden\";\n}, Pt = (e) => Array.from(e == null ? void 0 : e.querySelectorAll(\".carousel-item\")), Ft = (e) => e.offsetHeight, Ot = (e, t, s = !0) => {\n  if (!s) {\n    he(e);\n    return;\n  }\n  const r = Ht(t);\n  t.addEventListener(\"transitionend\", () => he(e), { once: !0 }), Xt(t, r);\n}, he = (e) => {\n  typeof e == \"function\" && e();\n}, Ht = (e) => {\n  if (!e)\n    return 0;\n  let { transitionDuration: t, transitionDelay: s } = window.getComputedStyle(e);\n  const r = Number.parseFloat(t), n = Number.parseFloat(s);\n  return !r && !n ? 0 : (t = t.split(\",\")[0], s = s.split(\",\")[0], (Number.parseFloat(t) + Number.parseFloat(s)) * 1e3);\n}, Wt = (e) => {\n  e.dispatchEvent(new Event(\"transitionend\"));\n}, Xt = (e, t) => {\n  let s = !1;\n  const n = t + 5;\n  function a() {\n    s = !0, e.removeEventListener(\"transitionend\", a);\n  }\n  e.addEventListener(\"transitionend\", a), setTimeout(() => {\n    s || Wt(e);\n  }, n);\n}, Ns = ({\n  fade: e = !1,\n  className: t,\n  carouselInnerClassName: s,\n  dark: r,\n  children: n,\n  interval: a = 5e3,\n  keyboard: c = !1,\n  touch: o = !0,\n  showControls: i,\n  showIndicators: u,\n  onSlide: d,\n  ...p\n}) => {\n  const m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]), g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0), v = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(!1), [b, T] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), [R, N] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), [k, D] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({ initialX: 0, initialY: 0 }), [S, E] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), F = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), W = clsx__WEBPACK_IMPORTED_MODULE_2__(\"carousel\", \"slide\", e && \"carousel-fade\", r && \"carousel-dark\", t), w = clsx__WEBPACK_IMPORTED_MODULE_2__(\"carousel-inner\", s), L = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (M, A) => {\n      if (A !== void 0)\n        h.current = A, T(A);\n      else {\n        const K = b === R - 1 ? 0 : b + 1, ee = b === 0 ? R - 1 : b - 1;\n        h.current = M === \"next\" ? K : ee, T(M === \"next\" ? K : ee);\n      }\n    },\n    [b, R]\n  ), I = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    g.current && (clearInterval(g.current), g.current = null);\n  }, []), O = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (M, A, K) => {\n      var pe;\n      if (!m.current || m.current.length < 2)\n        return;\n      E(!0);\n      const z = m.current[b], te = Boolean(g.current), oe = M === \"next\", ce = oe ? \"carousel-item-start\" : \"carousel-item-end\", ie = oe ? \"carousel-item-next\" : \"carousel-item-prev\";\n      if (A.classList.contains(\"active\")) {\n        v.current = !1;\n        return;\n      }\n      L(M, K), !(!z || !A) && (v.current = !0, te && I(), (pe = F.current) != null && pe.classList.contains(\"slide\") ? (A.classList.add(ie), Ft(A), z.classList.add(ce), A.classList.add(ce), Ot(() => {\n        E(!1), A.classList.remove(ce, ie), A.classList.add(\"active\"), z.classList.remove(\"active\", ie, ce), v.current = !1;\n      }, z, !0)) : (z.classList.remove(\"active\"), A.classList.add(\"active\"), v.current = !1));\n    },\n    [F, b, L, I]\n  ), $ = (M) => {\n    v.current || (v.current = !0, setTimeout(() => {\n      v.current = !1;\n    }, M));\n  }, C = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (M) => {\n      const A = M === \"prev\", z = (h.current + (A ? -1 : 1)) % R, te = m.current;\n      return z === -1 ? te[R - 1] : te[z];\n    },\n    [R]\n  ), H = (M) => {\n    const A = h.current, K = M > A ? \"next\" : \"prev\", ee = m.current;\n    return { direction: K, nextElement: ee[M] };\n  }, P = (M) => {\n    if (v.current || ($(700), M > R - 1 || M < 0))\n      return;\n    const { direction: A, nextElement: K } = H(M);\n    O(A, K, M);\n  }, X = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (M) => {\n      if (v.current)\n        return;\n      $(600);\n      const A = C(M);\n      O(M, A);\n    },\n    [C, O]\n  ), G = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    const { visibilityState: M, hidden: A } = document;\n    if (M)\n      return A || !At(F.current) ? void 0 : X(\"next\");\n    X(\"next\");\n  }, [F, X]), _ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    var A, K;\n    const M = (K = (A = n == null ? void 0 : n[b]) == null ? void 0 : A.props) == null ? void 0 : K.interval;\n    g.current && (clearInterval(g.current), g.current = null), g.current = setInterval(G, M || a);\n  }, [G, a, n, b]), J = (M) => {\n    o && D({ initialX: M.touches[0].clientX, initialY: M.touches[0].clientY });\n  }, Y = (M) => {\n    v.current = !0;\n    const { initialX: A, initialY: K } = k;\n    if (!A || !K)\n      return;\n    const ee = M.touches[0].clientX, z = M.touches[0].clientY, te = A - ee, oe = K - z;\n    Math.abs(te) > Math.abs(oe) && (te > 0 ? X(\"prev\") : X(\"next\")), D({ initialX: 0, initialY: 0 });\n  }, Q = () => {\n    v.current = !1;\n  }, Z = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (M) => {\n      switch (M.key) {\n        case \"ArrowLeft\":\n          M.preventDefault(), X(\"prev\");\n          break;\n        case \"ArrowRight\":\n          M.preventDefault(), X(\"next\");\n          break;\n      }\n    },\n    [X]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (c)\n      return window.addEventListener(\"keydown\", Z), () => {\n        window.removeEventListener(\"keydown\", Z);\n      };\n  }, [Z, c]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const M = F.current, A = Pt(M);\n    m.current = A, N(A.length);\n  }, [F]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    S && (d == null || d());\n  }, [S, d]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (_(), () => {\n    I();\n  }), [_, I]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    \"div\",\n    {\n      onTouchStart: J,\n      onTouchMove: Y,\n      onTouchEnd: Q,\n      onMouseEnter: I,\n      onMouseLeave: _,\n      className: W,\n      ref: F,\n      ...p,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: w, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(fe.Provider, { value: { active: b }, children: [\n        u && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(St, { to: P, imagesCount: R }),\n        n,\n        i && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ct, { move: X })\n      ] }) })\n    }\n  );\n}, ws = ({ className: e, children: t, itemId: s, ...r }) => {\n  const { active: n } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(fe), a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(!0), c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), o = clsx__WEBPACK_IMPORTED_MODULE_2__(\"carousel-item\", e);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (a.current && n === s - 1) {\n      const i = c.current;\n      i == null || i.classList.add(\"active\");\n    }\n    a.current = !1;\n  }, [n, s]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: o, ref: c, ...r, children: t });\n}, Bs = ({ className: e, children: t, ...s }) => {\n  const r = clsx__WEBPACK_IMPORTED_MODULE_2__(\"carousel-caption d-none d-md-block\", e);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: r, ...s, children: t });\n}, Be = react__WEBPACK_IMPORTED_MODULE_1__.createContext({\n  activeItem: 0,\n  setActiveItem: null,\n  alwaysOpen: !1,\n  initialActive: 0\n}), _t = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    alwaysOpen: e,\n    borderless: t,\n    className: s,\n    flush: r,\n    active: n,\n    initialActive: a = 0,\n    tag: c = \"div\",\n    children: o,\n    onChange: i,\n    ...u\n  }, d) => {\n    const p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => typeof n < \"u\", [n]), m = clsx__WEBPACK_IMPORTED_MODULE_2__(\"accordion\", r && \"accordion-flush\", t && \"accordion-borderless\", s), [g, h] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(a);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(c, { className: m, ref: d, ...u, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      Be.Provider,\n      {\n        value: { activeItem: p ? n : g, setActiveItem: h, alwaysOpen: e, initialActive: a, onChange: i },\n        children: o\n      }\n    ) });\n  }\n);\n_t.displayName = \"MDBAccordion\";\nconst jt = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(\n  ({\n    className: e,\n    bodyClassName: t,\n    bodyStyle: s,\n    headerClassName: r,\n    collapseId: n,\n    headerTitle: a,\n    headerStyle: c,\n    btnClassName: o,\n    tag: i = \"div\",\n    children: u,\n    ...d\n  }, p) => {\n    const { activeItem: m, setActiveItem: g, alwaysOpen: h, onChange: v } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Be), b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => Array.isArray(m) ? m.includes(n) : m === n, [m, n]), T = clsx__WEBPACK_IMPORTED_MODULE_2__(\"accordion-item\", e), R = clsx__WEBPACK_IMPORTED_MODULE_2__(\"accordion-header\", r), N = clsx__WEBPACK_IMPORTED_MODULE_2__(\"accordion-body\", t), k = clsx__WEBPACK_IMPORTED_MODULE_2__(\"accordion-button\", !b && \"collapsed\", o), D = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n      (S) => {\n        let E = S;\n        Array.isArray(m) ? m.includes(S) ? E = m.filter((W) => W !== S) : E = h ? [...m, S] : [S] : (E = m === S ? 0 : S, h && (E = [E])), v == null || v(E), g(E);\n      },\n      [v, m, g, h]\n    );\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(i, { className: T, ref: p, ...d, children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", { className: R, style: c, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", { onClick: () => D(n), className: k, type: \"button\", children: a }) }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(dt, { id: n.toString(), open: b, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: N, style: s, children: u }) })\n    ] });\n  }\n);\njt.displayName = \"MDBAccordionItem\";\nconst Ms = ({\n  className: e,\n  size: t,\n  contrast: s,\n  value: r,\n  defaultValue: n,\n  id: a,\n  labelClass: c,\n  wrapperClass: o,\n  wrapperStyle: i,\n  wrapperTag: u = \"div\",\n  label: d,\n  onChange: p,\n  children: m,\n  labelRef: g,\n  labelStyle: h,\n  inputRef: v,\n  onBlur: b,\n  readonly: T = !1,\n  ...R\n}) => {\n  var G;\n  const N = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), D = g || N, S = v || k, [E, F] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(r || n), [W, w] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), [L, I] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n    r !== void 0 && r.length > 0 || n !== void 0 && n.length > 0\n  ), O = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-outline\", s && \"form-white\", o), $ = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-control\", L && \"active\", t && `form-control-${t}`, e), C = clsx__WEBPACK_IMPORTED_MODULE_2__(\"form-label\", c);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var _;\n    D.current && ((_ = D.current) == null ? void 0 : _.clientWidth) !== 0 && w(D.current.clientWidth * 0.8 + 8);\n  }, [D, (G = D.current) == null ? void 0 : G.clientWidth]);\n  const H = () => {\n    D.current && w(D.current.clientWidth * 0.8 + 8);\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    r !== void 0 && (r.length > 0 ? I(!0) : I(!1));\n  }, [r]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    n !== void 0 && (n.length > 0 ? I(!0) : I(!1));\n  }, [n]);\n  const P = (_) => {\n    F(_.currentTarget.value), p && p(_);\n  }, X = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (_) => {\n      E !== void 0 && E.length > 0 || r !== void 0 && r.length > 0 ? I(!0) : I(!1), b && b(_);\n    },\n    [E, r, b]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(u, { className: O, style: { ...i }, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      \"textarea\",\n      {\n        readOnly: T,\n        className: $,\n        onBlur: X,\n        onChange: P,\n        onFocus: H,\n        defaultValue: n,\n        value: r,\n        id: a,\n        ref: S,\n        ...R\n      }\n    ),\n    d && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"label\", { className: C, style: h, htmlFor: a, ref: D, children: d }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { className: \"form-notch\", children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-notch-leading\" }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-notch-middle\", style: { width: W } }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"form-notch-trailing\" })\n    ] }),\n    m\n  ] });\n}, Ds = ({\n  children: e,\n  invalid: t,\n  feedback: s = \"Looks good!\",\n  tooltip: r,\n  tag: n = \"div\",\n  ...a\n}) => {\n  const [c, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), i = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null), u = clsx__WEBPACK_IMPORTED_MODULE_2__(\n    t ? `invalid-${r ? \"tooltip\" : \"feedback\"}` : `valid-${r ? \"tooltip\" : \"feedback\"}`\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var p, m;\n    const d = (m = (p = i.current) == null ? void 0 : p.querySelector(\"input, textarea\")) == null ? void 0 : m.parentElement;\n    d && o(d);\n  }, []), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(n, { ref: i, ...a, children: [\n    c && (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: u, children: s }), c),\n    e\n  ] });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRiLXJlYWN0LXVpLWtpdC9kaXN0L21kYi1yZWFjdC11aS1raXQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSxpQ0FBaUMsc0NBQXNDLGlGQUFpRixjQUFjLHNCQUFzQiw2SUFBNkksY0FBYyxzQkFBc0Isd0JBQXdCLGFBQWEsc0xBQXNMLFdBQVcseUJBQXlCLG9DQUFvQyxrQkFBa0Isa0NBQWtDLFNBQVMsbURBQW1EO0FBQ3R0QjtBQUNzSTtBQUN4TDtBQUM4QjtBQUNKO0FBQ0g7QUFDNUMsV0FBVyw2Q0FBWTtBQUN2QixLQUFLLDBFQUEwRTtBQUMvRSxjQUFjLGlDQUFDLElBQUksb0NBQW9DLGlCQUFpQixFQUFFO0FBQzFFLDJCQUEyQixzREFBQyxNQUFNLHlDQUF5QztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsaUNBQUM7QUFDZixrQkFBa0IsRUFBRTtBQUNwQixxQkFBcUIsRUFBRTtBQUN2QixxQkFBcUIsRUFBRTtBQUN2QixxQkFBcUIsRUFBRTtBQUN2QixxQkFBcUIsRUFBRTtBQUN2QixxQkFBcUIsRUFBRTtBQUN2QixzQkFBc0IsRUFBRTtBQUN4QjtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCLHdCQUF3QixFQUFFO0FBQzFCLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQUMsTUFBTSx5Q0FBeUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0Es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QUMseUNBQXlDLCtDQUFDLG1CQUFtQiwrQ0FBQyxjQUFjLCtDQUFDO0FBQ3ZHO0FBQ0EsU0FBUyxpQ0FBQyw0Q0FBNEMsaUNBQUMscURBQXFELEVBQUUsV0FBVyxpQ0FBQztBQUMxSCxFQUFFLGdEQUFDO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFDO0FBQ0g7QUFDQSxHQUFHLFFBQVEsZ0RBQUM7QUFDWjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxNQUFNLGtEQUFDO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCLHVEQUFDLE1BQU0sdUJBQXVCLE1BQU07QUFDN0Qsb0JBQW9CLHNEQUFDO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUMsWUFBWSx5REFBeUQ7QUFDL0Ysb0JBQW9CLHVEQUFDLFVBQVU7QUFDL0Isc0JBQXNCLHNEQUFDLFVBQVUsaUNBQWlDO0FBQ2xFLHNCQUFzQixzREFBQyxVQUFVLHlDQUF5QyxZQUFZO0FBQ3RGLHNCQUFzQixzREFBQyxVQUFVLGtDQUFrQztBQUNuRSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsK0NBQUMsWUFBWSw2Q0FBQyxZQUFZLGlDQUFDO0FBQzVDLG1CQUFtQiwyQkFBMkIsYUFBYSwyQkFBMkI7QUFDdEY7QUFDQSxTQUFTLGdEQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1QkFBdUIsdURBQUMsTUFBTTtBQUNqQyxTQUFTLHVEQUFFLGlCQUFpQixzREFBQyxVQUFVLDJCQUEyQjtBQUNsRTtBQUNBLEtBQUs7QUFDTDtBQWlGRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Bpbmlub2FwcC8uL25vZGVfbW9kdWxlcy9tZGItcmVhY3QtdWkta2l0L2Rpc3QvbWRiLXJlYWN0LXVpLWtpdC5lc20uanM/MmI1MSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50IT1cInVuZGVmaW5lZFwiKXt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7by5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5kcm9wZG93bi1tZW51IC5hY3RpdmU6bm90KC5mb3JtLWNvbnRyb2wpe2NvbG9yOiMxNjE4MWI7YmFja2dyb3VuZC1jb2xvcjojZWVlfS5kcm9wZG93bi1tZW51IFtkYXRhLWFjdGl2ZT10cnVlXSBhLmRyb3Bkb3duLWl0ZW0sLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06Zm9jdXMsLmRyb3Bkb3duLW1lbnUgbGk6Zm9jdXMgLmRyb3Bkb3duLWl0ZW0gOm5vdCguZGlzYWJsZWQpe2NvbG9yOiMxNjE4MWI7YmFja2dyb3VuZC1jb2xvcjojZWVlfS5kcm9wZG93bi1tZW51IGxpOmZvY3Vze291dGxpbmU6bm9uZX0uZHJvcGRvd24tbWVudS5kcm9wZG93bi1tZW51LWRhcmsgW2RhdGEtYWN0aXZlPXRydWVdIGEuZHJvcGRvd24taXRlbSwuZHJvcGRvd24tbWVudS5kcm9wZG93bi1tZW51LWRhcmsgLmRyb3Bkb3duLWl0ZW06Zm9jdXMsLmRyb3Bkb3duLW1lbnUuZHJvcGRvd24tbWVudS1kYXJrIGxpOmZvY3VzIC5kcm9wZG93bi1pdGVte2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMTI2NmYxfS5idG4tZ3JvdXAuZHJvcHN0YXJ0Pi5kcm9wZG93bi1tZW51e3JpZ2h0OjAhaW1wb3J0YW50fVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChvKX19Y2F0Y2goZCl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLGQpfX0pKCk7XG5pbXBvcnQgeyBqc3ggYXMgbCwganN4cyBhcyBWLCBGcmFnbWVudCBhcyBVIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeSwgeyB1c2VTdGF0ZSBhcyBCLCB1c2VFZmZlY3QgYXMgeCwgdXNlUmVmIGFzIHEsIHVzZUNhbGxiYWNrIGFzIGosIHVzZU1lbW8gYXMgYWUsIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgTWUsIGNyZWF0ZUNvbnRleHQgYXMgYmUsIHVzZUNvbnRleHQgYXMgc2UsIENoaWxkcmVuIGFzIERlLCBjbG9uZUVsZW1lbnQgYXMgVGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBmIGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgbmUsIHsgY3JlYXRlUG9ydGFsIGFzIHZlIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgdXNlUG9wcGVyIGFzIGRlIH0gZnJvbSBcInJlYWN0LXBvcHBlclwiO1xuaW1wb3J0IHsgZmxpcCBhcyBSZSB9IGZyb20gXCJAcG9wcGVyanMvY29yZVwiO1xuY29uc3QgJGUgPSB5LmZvcndhcmRSZWYoXG4gICh7IGJyZWFrcG9pbnQ6IGUsIGZsdWlkOiB0LCBjaGlsZHJlbjogcywgY2xhc3NOYW1lOiByLCB0YWc6IG4gPSBcImRpdlwiLCAuLi5hIH0sIGMpID0+IHtcbiAgICBjb25zdCBvID0gZihgJHt0ID8gXCJjb250YWluZXItZmx1aWRcIiA6IGBjb250YWluZXIke2UgPyBcIi1cIiArIGUgOiBcIlwifWB9YCwgcik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKG4sIHsgY2xhc3NOYW1lOiBvLCAuLi5hLCByZWY6IGMsIGNoaWxkcmVuOiBzIH0pO1xuICB9XG4pO1xuJGUuZGlzcGxheU5hbWUgPSBcIk1EQkNvbnRhaW5lclwiO1xuY29uc3QgRWUgPSB5LmZvcndhcmRSZWYoXG4gICh7XG4gICAgY2VudGVyOiBlLFxuICAgIGNoaWxkcmVuOiB0LFxuICAgIGNsYXNzTmFtZTogcyxcbiAgICBlbmQ6IHIsXG4gICAgbGc6IG4sXG4gICAgbWQ6IGEsXG4gICAgb2Zmc2V0TGc6IGMsXG4gICAgb2Zmc2V0TWQ6IG8sXG4gICAgb2Zmc2V0U206IGksXG4gICAgb3JkZXI6IHUsXG4gICAgc2l6ZTogZCxcbiAgICBzbTogcCxcbiAgICBzdGFydDogbSxcbiAgICB0YWc6IGcgPSBcImRpdlwiLFxuICAgIHhsOiBoLFxuICAgIHh4bDogdixcbiAgICB4czogYixcbiAgICAuLi5UXG4gIH0sIFIpID0+IHtcbiAgICBjb25zdCBOID0gZihcbiAgICAgIGQgJiYgYGNvbC0ke2R9YCxcbiAgICAgIGIgJiYgYGNvbC14cy0ke2J9YCxcbiAgICAgIHAgJiYgYGNvbC1zbS0ke3B9YCxcbiAgICAgIGEgJiYgYGNvbC1tZC0ke2F9YCxcbiAgICAgIG4gJiYgYGNvbC1sZy0ke259YCxcbiAgICAgIGggJiYgYGNvbC14bC0ke2h9YCxcbiAgICAgIHYgJiYgYGNvbC14eGwtJHt2fWAsXG4gICAgICAhZCAmJiAhYiAmJiAhcCAmJiAhYSAmJiAhbiAmJiAhaCAmJiAhdiA/IFwiY29sXCIgOiBcIlwiLFxuICAgICAgdSAmJiBgb3JkZXItJHt1fWAsXG4gICAgICBtICYmIFwiYWxpZ24tc2VsZi1zdGFydFwiLFxuICAgICAgZSAmJiBcImFsaWduLXNlbGYtY2VudGVyXCIsXG4gICAgICByICYmIFwiYWxpZ24tc2VsZi1lbmRcIixcbiAgICAgIGkgJiYgYG9mZnNldC1zbS0ke2l9YCxcbiAgICAgIG8gJiYgYG9mZnNldC1tZC0ke299YCxcbiAgICAgIGMgJiYgYG9mZnNldC1sZy0ke2N9YCxcbiAgICAgIHNcbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChnLCB7IGNsYXNzTmFtZTogTiwgcmVmOiBSLCAuLi5ULCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcbkVlLmRpc3BsYXlOYW1lID0gXCJNREJDb2xcIjtcbmNvbnN0IEllID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNvbG9yOiB0ID0gXCJwcmltYXJ5XCIsIHBpbGw6IHMsIGxpZ2h0OiByLCBkb3Q6IG4sIHRhZzogYSA9IFwic3BhblwiLCBjaGlsZHJlbjogYywgbm90aWZpY2F0aW9uOiBvLCAuLi5pIH0sIHUpID0+IHtcbiAgICBjb25zdCBkID0gZihcbiAgICAgIFwiYmFkZ2VcIixcbiAgICAgIHIgPyB0ICYmIGBiYWRnZS0ke3R9YCA6IHQgJiYgYGJnLSR7dH1gLFxuICAgICAgbiAmJiBcImJhZGdlLWRvdFwiLFxuICAgICAgcyAmJiBcInJvdW5kZWQtcGlsbFwiLFxuICAgICAgbyAmJiBcImJhZGdlLW5vdGlmaWNhdGlvblwiLFxuICAgICAgZVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKGEsIHsgY2xhc3NOYW1lOiBkLCByZWY6IHUsIC4uLmksIGNoaWxkcmVuOiBjIH0pO1xuICB9XG4pO1xuSWUuZGlzcGxheU5hbWUgPSBcIk1EQkJhZGdlXCI7XG5jb25zdCBMZSA9ICh7IC4uLmUgfSkgPT4ge1xuICBjb25zdCBbdCwgc10gPSBCKCExKSwgciA9IGYoXCJyaXBwbGUtd2F2ZVwiLCB0ICYmIFwiYWN0aXZlXCIpO1xuICByZXR1cm4geCgoKSA9PiB7XG4gICAgY29uc3QgbiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcyghMCk7XG4gICAgfSwgNTApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQobik7XG4gICAgfTtcbiAgfSwgW10pLCAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogciwgLi4uZSB9KTtcbn0sIHhlID0gKC4uLmUpID0+IHtcbiAgY29uc3QgdCA9IHkudXNlUmVmKCk7XG4gIHJldHVybiB5LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBzICYmICh0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgPyBzKHQuY3VycmVudCkgOiBzLmN1cnJlbnQgPSB0LmN1cnJlbnQpO1xuICAgIH0pO1xuICB9LCBbZV0pLCB0O1xufSwgeWUgPSB5LmZvcndhcmRSZWYoXG4gICh7XG4gICAgY2xhc3NOYW1lOiBlLFxuICAgIHJpcHBsZVRhZzogdCA9IFwiZGl2XCIsXG4gICAgcmlwcGxlQ2VudGVyZWQ6IHMsXG4gICAgcmlwcGxlRHVyYXRpb246IHIgPSA1MDAsXG4gICAgcmlwcGxlVW5ib3VuZDogbixcbiAgICByaXBwbGVSYWRpdXM6IGEgPSAwLFxuICAgIHJpcHBsZUNvbG9yOiBjID0gXCJkYXJrXCIsXG4gICAgY2hpbGRyZW46IG8sXG4gICAgb25Nb3VzZURvd246IGksXG4gICAgLi4udVxuICB9LCBkKSA9PiB7XG4gICAgY29uc3QgcCA9IHEobnVsbCksIG0gPSB4ZShkLCBwKSwgZyA9IFwicmdiYSh7e2NvbG9yfX0sIDAuMikgMCwgcmdiYSh7e2NvbG9yfX0sIDAuMykgNDAlLCByZ2JhKHt7Y29sb3J9fSwgMC40KSA1MCUsIHJnYmEoe3tjb2xvcn19LCAwLjUpIDYwJSwgcmdiYSh7e2NvbG9yfX0sIDApIDcwJVwiLCBoID0gWzAsIDAsIDBdLCB2ID0gW1wicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcInN1Y2Nlc3NcIiwgXCJkYW5nZXJcIiwgXCJ3YXJuaW5nXCIsIFwiaW5mb1wiLCBcImxpZ2h0XCIsIFwiZGFya1wiXSwgW2IsIFRdID0gQihbXSksIFtSLCBOXSA9IEIoITEpLCBrID0gZihcbiAgICAgIFwicmlwcGxlXCIsXG4gICAgICBcInJpcHBsZS1zdXJmYWNlXCIsXG4gICAgICBuICYmIFwicmlwcGxlLXN1cmZhY2UtdW5ib3VuZFwiLFxuICAgICAgUiAmJiBgcmlwcGxlLXN1cmZhY2UtJHtjfWAsXG4gICAgICBlXG4gICAgKSwgRCA9ICgpID0+IHtcbiAgICAgIGlmICh2LmZpbmQoKEwpID0+IEwgPT09IChjID09IG51bGwgPyB2b2lkIDAgOiBjLnRvTG93ZXJDYXNlKCkpKSlcbiAgICAgICAgcmV0dXJuIE4oITApO1xuICAgICAge1xuICAgICAgICBjb25zdCBMID0gUyhjKS5qb2luKFwiLFwiKTtcbiAgICAgICAgcmV0dXJuIGByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCAke2cuc3BsaXQoXCJ7e2NvbG9yfX1cIikuam9pbihgJHtMfWApfSlgO1xuICAgICAgfVxuICAgIH0sIFMgPSAodykgPT4ge1xuICAgICAgY29uc3QgTCA9ICgkKSA9PiAoJC5sZW5ndGggPCA3ICYmICgkID0gYCMkeyRbMV19JHskWzFdfSR7JFsyXX0keyRbMl19JHskWzNdfSR7JFszXX1gKSwgW3BhcnNlSW50KCQuc3Vic3RyKDEsIDIpLCAxNiksIHBhcnNlSW50KCQuc3Vic3RyKDMsIDIpLCAxNiksIHBhcnNlSW50KCQuc3Vic3RyKDUsIDIpLCAxNildKSwgSSA9ICgkKSA9PiB7XG4gICAgICAgIGNvbnN0IEMgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWN0dW1cIikpLCBIID0gXCJyZ2IoMSwgMiwgMylcIjtcbiAgICAgICAgcmV0dXJuIEMuc3R5bGUuY29sb3IgPSBILCBDLnN0eWxlLmNvbG9yICE9PSBIIHx8IChDLnN0eWxlLmNvbG9yID0gJCwgQy5zdHlsZS5jb2xvciA9PT0gSCB8fCBDLnN0eWxlLmNvbG9yID09PSBcIlwiKSA/IGggOiAoJCA9IGdldENvbXB1dGVkU3R5bGUoQykuY29sb3IsIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoQyksICQpO1xuICAgICAgfSwgTyA9ICgkKSA9PiAoJCA9ICQubWF0Y2goL1suXFxkXSsvZykubWFwKChDKSA9PiArTnVtYmVyKEMpKSwgJC5sZW5ndGggPSAzLCAkKTtcbiAgICAgIHJldHVybiB3LnRvTG93ZXJDYXNlKCkgPT09IFwidHJhbnNwYXJlbnRcIiA/IGggOiB3WzBdID09PSBcIiNcIiA/IEwodykgOiAody5pbmRleE9mKFwicmdiXCIpID09PSAtMSAmJiAodyA9IEkodykpLCB3LmluZGV4T2YoXCJyZ2JcIikgPT09IDAgPyBPKHcpIDogaCk7XG4gICAgfSwgRSA9ICh3KSA9PiB7XG4gICAgICBjb25zdCB7IG9mZnNldFg6IEwsIG9mZnNldFk6IEksIGhlaWdodDogTywgd2lkdGg6ICQgfSA9IHcsIEMgPSBJIDw9IE8gLyAyLCBIID0gTCA8PSAkIC8gMiwgUCA9IChZLCBRKSA9PiBNYXRoLnNxcnQoWSAqKiAyICsgUSAqKiAyKSwgWCA9IEkgPT09IE8gLyAyICYmIEwgPT09ICQgLyAyLCBHID0ge1xuICAgICAgICBmaXJzdDogQyA9PT0gITAgJiYgSCA9PT0gITEsXG4gICAgICAgIHNlY29uZDogQyA9PT0gITAgJiYgSCA9PT0gITAsXG4gICAgICAgIHRoaXJkOiBDID09PSAhMSAmJiBIID09PSAhMCxcbiAgICAgICAgZm91cnRoOiBDID09PSAhMSAmJiBIID09PSAhMVxuICAgICAgfSwgXyA9IHtcbiAgICAgICAgdG9wTGVmdDogUChMLCBJKSxcbiAgICAgICAgdG9wUmlnaHQ6IFAoJCAtIEwsIEkpLFxuICAgICAgICBib3R0b21MZWZ0OiBQKEwsIE8gLSBJKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFAoJCAtIEwsIE8gLSBJKVxuICAgICAgfTtcbiAgICAgIGxldCBKID0gMDtcbiAgICAgIHJldHVybiBYIHx8IEcuZm91cnRoID8gSiA9IF8udG9wTGVmdCA6IEcudGhpcmQgPyBKID0gXy50b3BSaWdodCA6IEcuc2Vjb25kID8gSiA9IF8uYm90dG9tUmlnaHQgOiBHLmZpcnN0ICYmIChKID0gXy5ib3R0b21MZWZ0KSwgSiAqIDI7XG4gICAgfSwgRiA9ICh3KSA9PiB7XG4gICAgICB2YXIgSjtcbiAgICAgIGNvbnN0IEwgPSAoSiA9IG0uY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IEouZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIEkgPSB3LmNsaWVudFggLSBMLmxlZnQsIE8gPSB3LmNsaWVudFkgLSBMLnRvcCwgJCA9IEwuaGVpZ2h0LCBDID0gTC53aWR0aCwgSCA9IHtcbiAgICAgICAgb2Zmc2V0WDogcyA/ICQgLyAyIDogSSxcbiAgICAgICAgb2Zmc2V0WTogcyA/IEMgLyAyIDogTyxcbiAgICAgICAgaGVpZ2h0OiAkLFxuICAgICAgICB3aWR0aDogQ1xuICAgICAgfSwgUCA9IHtcbiAgICAgICAgZGVsYXk6IHIgJiYgciAqIDAuNSxcbiAgICAgICAgZHVyYXRpb246IHIgJiYgciAtIHIgKiAwLjVcbiAgICAgIH0sIFggPSBFKEgpLCBHID0gYSB8fCBYIC8gMiwgXyA9IHtcbiAgICAgICAgbGVmdDogcyA/IGAke0MgLyAyIC0gR31weGAgOiBgJHtJIC0gR31weGAsXG4gICAgICAgIHRvcDogcyA/IGAkeyQgLyAyIC0gR31weGAgOiBgJHtPIC0gR31weGAsXG4gICAgICAgIGhlaWdodDogYSA/IGAke2EgKiAyfXB4YCA6IGAke1h9cHhgLFxuICAgICAgICB3aWR0aDogYSA/IGAke2EgKiAyfXB4YCA6IGAke1h9cHhgLFxuICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IGAwcywgJHtQLmRlbGF5fW1zYCxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtyfW1zLCAke1AuZHVyYXRpb259bXNgXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFIgPyBfIDogeyAuLi5fLCBiYWNrZ3JvdW5kSW1hZ2U6IGAke0QoKX1gIH07XG4gICAgfSwgVyA9ICh3KSA9PiB7XG4gICAgICBjb25zdCBMID0gRih3KSwgSSA9IGIuY29uY2F0KEwpO1xuICAgICAgVChJKSwgaSAmJiBpKHcpO1xuICAgIH07XG4gICAgcmV0dXJuIHgoKCkgPT4ge1xuICAgICAgY29uc3QgdyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBiLmxlbmd0aCA+IDAgJiYgVChiLnNwbGljZSgxLCBiLmxlbmd0aCAtIDEpKTtcbiAgICAgIH0sIHIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHcpO1xuICAgICAgfTtcbiAgICB9LCBbciwgYl0pLCAvKiBAX19QVVJFX18gKi8gVih0LCB7IGNsYXNzTmFtZTogaywgb25Nb3VzZURvd246ICh3KSA9PiBXKHcpLCByZWY6IG0sIC4uLnUsIGNoaWxkcmVuOiBbXG4gICAgICBvLFxuICAgICAgYi5tYXAoKHcsIEwpID0+IC8qIEBfX1BVUkVfXyAqLyBsKExlLCB7IHN0eWxlOiB3IH0sIEwpKVxuICAgIF0gfSk7XG4gIH1cbik7XG55ZS5kaXNwbGF5TmFtZSA9IFwiTURCUmlwcGxlXCI7XG5jb25zdCBsZSA9IHkuZm9yd2FyZFJlZihcbiAgKHtcbiAgICBjbGFzc05hbWU6IGUsXG4gICAgY29sb3I6IHQgPSBcInByaW1hcnlcIixcbiAgICBvdXRsaW5lOiBzLFxuICAgIGNoaWxkcmVuOiByLFxuICAgIHJvdW5kZWQ6IG4sXG4gICAgZGlzYWJsZWQ6IGEsXG4gICAgZmxvYXRpbmc6IGMsXG4gICAgc2l6ZTogbyxcbiAgICBocmVmOiBpLFxuICAgIGJsb2NrOiB1LFxuICAgIGFjdGl2ZTogZCxcbiAgICB0b2dnbGU6IHAsXG4gICAgbm9SaXBwbGU6IG0sXG4gICAgdGFnOiBnID0gXCJidXR0b25cIixcbiAgICByb2xlOiBoID0gXCJidXR0b25cIixcbiAgICAuLi52XG4gIH0sIGIpID0+IHtcbiAgICBjb25zdCBbVCwgUl0gPSBCKGQgfHwgITEpO1xuICAgIGxldCBOO1xuICAgIGNvbnN0IGsgPSB0ICYmIFtcImxpZ2h0XCIsIFwibGlua1wiXS5pbmNsdWRlcyh0KSB8fCBzID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG4gICAgdCAhPT0gXCJub25lXCIgPyBzID8gdCA/IE4gPSBgYnRuLW91dGxpbmUtJHt0fWAgOiBOID0gXCJidG4tb3V0bGluZS1wcmltYXJ5XCIgOiB0ID8gTiA9IGBidG4tJHt0fWAgOiBOID0gXCJidG4tcHJpbWFyeVwiIDogTiA9IFwiXCI7XG4gICAgY29uc3QgRCA9IGYoXG4gICAgICB0ICE9PSBcIm5vbmVcIiAmJiBcImJ0blwiLFxuICAgICAgTixcbiAgICAgIG4gJiYgXCJidG4tcm91bmRlZFwiLFxuICAgICAgYyAmJiBcImJ0bi1mbG9hdGluZ1wiLFxuICAgICAgbyAmJiBgYnRuLSR7b31gLFxuICAgICAgYCR7KGkgfHwgZyAhPT0gXCJidXR0b25cIikgJiYgYSA/IFwiZGlzYWJsZWRcIiA6IFwiXCJ9YCxcbiAgICAgIHUgJiYgXCJidG4tYmxvY2tcIixcbiAgICAgIFQgJiYgXCJhY3RpdmVcIixcbiAgICAgIGVcbiAgICApO1xuICAgIHJldHVybiBpICYmIGcgIT09IFwiYVwiICYmIChnID0gXCJhXCIpLCBbXCJoclwiLCBcImltZ1wiLCBcImlucHV0XCJdLmluY2x1ZGVzKGcpIHx8IG0gPyAvKiBAX19QVVJFX18gKi8gbChcbiAgICAgIGcsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogRCxcbiAgICAgICAgb25DbGljazogcCA/ICgpID0+IHtcbiAgICAgICAgICBSKCFUKTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgZGlzYWJsZWQ6IGEgJiYgZyA9PT0gXCJidXR0b25cIiA/ICEwIDogdm9pZCAwLFxuICAgICAgICBocmVmOiBpLFxuICAgICAgICByZWY6IGIsXG4gICAgICAgIHJvbGU6IGgsXG4gICAgICAgIC4uLnYsXG4gICAgICAgIGNoaWxkcmVuOiByXG4gICAgICB9XG4gICAgKSA6IC8qIEBfX1BVUkVfXyAqLyBsKFxuICAgICAgeWUsXG4gICAgICB7XG4gICAgICAgIHJpcHBsZVRhZzogZyxcbiAgICAgICAgcmlwcGxlQ29sb3I6IGssXG4gICAgICAgIGNsYXNzTmFtZTogRCxcbiAgICAgICAgb25DbGljazogcCA/ICgpID0+IHtcbiAgICAgICAgICBSKCFUKTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgZGlzYWJsZWQ6IGEgJiYgZyA9PT0gXCJidXR0b25cIiA/ICEwIDogdm9pZCAwLFxuICAgICAgICBocmVmOiBpLFxuICAgICAgICByZWY6IGIsXG4gICAgICAgIHJvbGU6IGgsXG4gICAgICAgIC4uLnYsXG4gICAgICAgIGNoaWxkcmVuOiByXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcbmxlLmRpc3BsYXlOYW1lID0gXCJNREJCdG5cIjtcbmNvbnN0IGtlID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCBzaGFkb3c6IHMsIHRvb2xiYXI6IHIsIHNpemU6IG4sIHZlcnRpY2FsOiBhLCB0YWc6IGMgPSBcImRpdlwiLCByb2xlOiBvID0gXCJncm91cFwiLCAuLi5pIH0sIHUpID0+IHtcbiAgICBsZXQgZDtcbiAgICByID8gZCA9IFwiYnRuLXRvb2xiYXJcIiA6IGEgPyBkID0gXCJidG4tZ3JvdXAtdmVydGljYWxcIiA6IGQgPSBcImJ0bi1ncm91cFwiO1xuICAgIGNvbnN0IHAgPSBmKGQsIHMgJiYgYHNoYWRvdy0ke3N9YCwgbiAmJiBgYnRuLWdyb3VwLSR7bn1gLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwoYywgeyBjbGFzc05hbWU6IHAsIHJlZjogdSwgcm9sZTogbywgLi4uaSwgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5rZS5kaXNwbGF5TmFtZSA9IFwiTURCQnRuR3JvdXBcIjtcbmNvbnN0IFNlID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCB0YWc6IHMgPSBcImRpdlwiLCBjb2xvcjogciwgZ3Jvdzogbiwgc2l6ZTogYSwgLi4uYyB9LCBvKSA9PiB7XG4gICAgY29uc3QgaSA9IGYoXG4gICAgICBgJHtuID8gXCJzcGlubmVyLWdyb3dcIiA6IFwic3Bpbm5lci1ib3JkZXJcIn1gLFxuICAgICAgciAmJiBgdGV4dC0ke3J9YCxcbiAgICAgIGAke2EgPyBuID8gXCJzcGlubmVyLWdyb3ctXCIgKyBhIDogXCJzcGlubmVyLWJvcmRlci1cIiArIGEgOiBcIlwifWAsXG4gICAgICBlXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwocywgeyBjbGFzc05hbWU6IGksIHJlZjogbywgLi4uYywgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5TZS5kaXNwbGF5TmFtZSA9IFwiTURCU3Bpbm5lclwiO1xuY29uc3QgQ2UgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNsYXNzTmFtZTogZSwgY2hpbGRyZW46IHQsIGJvcmRlcjogcywgYmFja2dyb3VuZDogciwgdGFnOiBuID0gXCJkaXZcIiwgc2hhZG93OiBhLCBhbGlnbm1lbnQ6IGMsIC4uLm8gfSwgaSkgPT4ge1xuICAgIGNvbnN0IHUgPSBmKFxuICAgICAgXCJjYXJkXCIsXG4gICAgICBzICYmIGBib3JkZXIgYm9yZGVyLSR7c31gLFxuICAgICAgciAmJiBgYmctJHtyfWAsXG4gICAgICBhICYmIGBzaGFkb3ctJHthfWAsXG4gICAgICBjICYmIGB0ZXh0LSR7Y31gLFxuICAgICAgZVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKG4sIHsgY2xhc3NOYW1lOiB1LCByZWY6IGksIC4uLm8sIGNoaWxkcmVuOiB0IH0pO1xuICB9XG4pO1xuQ2UuZGlzcGxheU5hbWUgPSBcIk1EQkNhcmRcIjtcbmNvbnN0IEFlID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCBib3JkZXI6IHMsIGJhY2tncm91bmQ6IHIsIHRhZzogbiA9IFwiZGl2XCIsIC4uLmEgfSwgYykgPT4ge1xuICAgIGNvbnN0IG8gPSBmKFwiY2FyZC1oZWFkZXJcIiwgcyAmJiBgYm9yZGVyLSR7c31gLCByICYmIGBiZy0ke3J9YCwgZSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKG4sIHsgY2xhc3NOYW1lOiBvLCAuLi5hLCByZWY6IGMsIGNoaWxkcmVuOiB0IH0pO1xuICB9XG4pO1xuQWUuZGlzcGxheU5hbWUgPSBcIk1EQkNhcmRIZWFkZXJcIjtcbmNvbnN0IFBlID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCB0YWc6IHMgPSBcInBcIiwgLi4uciB9LCBuKSA9PiB7XG4gICAgY29uc3QgYSA9IGYoXCJjYXJkLXN1YnRpdGxlXCIsIGUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogYSwgLi4uciwgcmVmOiBuLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcblBlLmRpc3BsYXlOYW1lID0gXCJNREJDYXJkU3ViVGl0bGVcIjtcbmNvbnN0IEZlID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCB0YWc6IHMgPSBcImg1XCIsIC4uLnIgfSwgbikgPT4ge1xuICAgIGNvbnN0IGEgPSBmKFwiY2FyZC10aXRsZVwiLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwocywgeyBjbGFzc05hbWU6IGEsIC4uLnIsIHJlZjogbiwgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5GZS5kaXNwbGF5TmFtZSA9IFwiTURCQ2FyZFRpdGxlXCI7XG5jb25zdCBPZSA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgdGFnOiBzID0gXCJwXCIsIC4uLnIgfSwgbikgPT4ge1xuICAgIGNvbnN0IGEgPSBmKFwiY2FyZC10ZXh0XCIsIGUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogYSwgLi4uciwgcmVmOiBuLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcbk9lLmRpc3BsYXlOYW1lID0gXCJNREJDYXJkVGV4dFwiO1xuY29uc3QgSGUgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNsYXNzTmFtZTogZSwgY2hpbGRyZW46IHQsIHRhZzogcyA9IFwiZGl2XCIsIC4uLnIgfSwgbikgPT4ge1xuICAgIGNvbnN0IGEgPSBmKFwiY2FyZC1ib2R5XCIsIGUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogYSwgLi4uciwgcmVmOiBuLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcbkhlLmRpc3BsYXlOYW1lID0gXCJNREJDYXJkQm9keVwiO1xuY29uc3QgV2UgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNsYXNzTmFtZTogZSwgY2hpbGRyZW46IHQsIGJvcmRlcjogcywgYmFja2dyb3VuZDogciwgdGFnOiBuID0gXCJkaXZcIiwgLi4uYSB9LCBjKSA9PiB7XG4gICAgY29uc3QgbyA9IGYoXCJjYXJkLWZvb3RlclwiLCBzICYmIGBib3JkZXItJHtzfWAsIHIgJiYgYGJnLSR7cn1gLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwobiwgeyBjbGFzc05hbWU6IG8sIC4uLmEsIHJlZjogYywgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5XZS5kaXNwbGF5TmFtZSA9IFwiTURCQ2FyZEZvb3RlclwiO1xuY29uc3QgUXQgPSAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCBvdmVybGF5OiBzLCBwb3NpdGlvbjogciwgZmx1aWQ6IG4sIC4uLmEgfSkgPT4ge1xuICBjb25zdCBjID0gZihyICYmIGBjYXJkLWltZy0ke3J9YCwgbiAmJiBcImltZy1mbHVpZFwiLCBzICYmIFwiY2FyZC1pbWdcIiwgZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcImltZ1wiLCB7IGNsYXNzTmFtZTogYywgLi4uYSwgY2hpbGRyZW46IHQgfSk7XG59LCBYZSA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgdGFnOiBzID0gXCJkaXZcIiwgLi4uciB9LCBuKSA9PiB7XG4gICAgY29uc3QgYSA9IGYoXCJjYXJkLWltZy1vdmVybGF5XCIsIGUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogYSwgLi4uciwgcmVmOiBuLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcblhlLmRpc3BsYXlOYW1lID0gXCJNREJDYXJkT3ZlcmxheVwiO1xuY29uc3QgWnQgPSAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCAuLi5zIH0pID0+IHtcbiAgY29uc3QgciA9IGYoXCJjYXJkLWxpbmtcIiwgZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcImFcIiwgeyBjbGFzc05hbWU6IHIsIC4uLnMsIGNoaWxkcmVuOiB0IH0pO1xufSwgX2UgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNsYXNzTmFtZTogZSwgY2hpbGRyZW46IHQsIHRhZzogcyA9IFwiZGl2XCIsIC4uLnIgfSwgbikgPT4ge1xuICAgIGNvbnN0IGEgPSBmKFwiY2FyZC1ncm91cFwiLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwocywgeyBjbGFzc05hbWU6IGEsIC4uLnIsIHJlZjogbiwgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5fZS5kaXNwbGF5TmFtZSA9IFwiTURCQ2FyZEdyb3VwXCI7XG5jb25zdCBqZSA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCB0YWc6IHQgPSBcInVsXCIsIGhvcml6b250YWw6IHMsIGhvcml6b250YWxTaXplOiByLCBsaWdodDogbiwgbnVtYmVyZWQ6IGEsIGNoaWxkcmVuOiBjLCBzbWFsbDogbywgLi4uaSB9LCB1KSA9PiB7XG4gICAgY29uc3QgZCA9IGYoXG4gICAgICBcImxpc3QtZ3JvdXBcIixcbiAgICAgIHMgJiYgKHIgPyBgbGlzdC1ncm91cC1ob3Jpem9udGFsLSR7cn1gIDogXCJsaXN0LWdyb3VwLWhvcml6b250YWxcIiksXG4gICAgICBuICYmIFwibGlzdC1ncm91cC1saWdodFwiLFxuICAgICAgYSAmJiBcImxpc3QtZ3JvdXAtbnVtYmVyZWRcIixcbiAgICAgIG8gJiYgXCJsaXN0LWdyb3VwLXNtYWxsXCIsXG4gICAgICBlXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwodCwgeyBjbGFzc05hbWU6IGQsIHJlZjogdSwgLi4uaSwgY2hpbGRyZW46IGMgfSk7XG4gIH1cbik7XG5qZS5kaXNwbGF5TmFtZSA9IFwiTURCTGlzdEdyb3VwXCI7XG5jb25zdCBHZSA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCB0YWc6IHQgPSBcImxpXCIsIGFjdGl2ZTogcywgZGlzYWJsZWQ6IHIsIGFjdGlvbjogbiwgY29sb3I6IGEsIGNoaWxkcmVuOiBjLCBub0JvcmRlcnM6IG8sIC4uLmkgfSwgdSkgPT4ge1xuICAgIGNvbnN0IGQgPSB0ID09PSBcImJ1dHRvblwiLCBwID0gZihcbiAgICAgIFwibGlzdC1ncm91cC1pdGVtXCIsXG4gICAgICBzICYmIFwiYWN0aXZlXCIsXG4gICAgICByICYmICFkICYmIFwiZGlzYWJsZWRcIixcbiAgICAgIG4gJiYgXCJsaXN0LWdyb3VwLWl0ZW0tYWN0aW9uXCIsXG4gICAgICBhICYmIGBsaXN0LWdyb3VwLWl0ZW0tJHthfWAsXG4gICAgICBvICYmIFwiYm9yZGVyLTBcIixcbiAgICAgIGVcbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbCh0LCB7IGNsYXNzTmFtZTogcCwgZGlzYWJsZWQ6IGQgJiYgciwgcmVmOiB1LCAuLi5pLCBjaGlsZHJlbjogYyB9KTtcbiAgfVxuKTtcbkdlLmRpc3BsYXlOYW1lID0gXCJNREJMaXN0R3JvdXBJdGVtXCI7XG5jb25zdCB6dCA9ICh7XG4gIGNsYXNzTmFtZTogZSxcbiAgY2hpbGRyZW46IHQsXG4gIGRpc2FibGVNb3VzZURvd246IHMsXG4gIHRhZzogciA9IGxlLFxuICB0b29sdGlwVGFnOiBuID0gXCJkaXZcIixcbiAgb3B0aW9uczogYSxcbiAgcGxhY2VtZW50OiBjID0gXCJ0b3BcIixcbiAgdGl0bGU6IG8sXG4gIHdyYXBwZXJQcm9wczogaSxcbiAgd3JhcHBlckNsYXNzOiB1LFxuICBvbk9wZW46IGQsXG4gIG9uQ2xvc2U6IHAsXG4gIG9uTW91c2VFbnRlcjogbSxcbiAgb25Nb3VzZUxlYXZlOiBnLFxuICAuLi5oXG59KSA9PiB7XG4gIGNvbnN0IFt2LCBiXSA9IEIobnVsbCksIFtULCBSXSA9IEIobnVsbCksIFtOLCBrXSA9IEIoITEpLCBbRCwgU10gPSBCKCExKSwgW0UsIEZdID0gQighMSksIFtXLCB3XSA9IEIoITEpLCBMID0gZihcInRvb2x0aXBcIiwgRSAmJiBcInNob3dcIiwgXCJmYWRlXCIsIGUpLCB7IHN0eWxlczogSSwgYXR0cmlidXRlczogTyB9ID0gZGUodiwgVCwge1xuICAgIHBsYWNlbWVudDogYyxcbiAgICAuLi5hXG4gIH0pO1xuICB4KCgpID0+IHtcbiAgICBsZXQgUCwgWDtcbiAgICByZXR1cm4gTiB8fCBEID8gKHcoITApLCBQID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBGKCEwKTtcbiAgICB9LCA0KSkgOiAoRighMSksIFggPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHcoITEpO1xuICAgIH0sIDMwMCkpLCAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoUCksIGNsZWFyVGltZW91dChYKTtcbiAgICB9O1xuICB9LCBbTiwgRF0pO1xuICBjb25zdCAkID0gKFApID0+IHtcbiAgICBkID09IG51bGwgfHwgZChQKSwgIVAuZGVmYXVsdFByZXZlbnRlZCAmJiBrKCEwKSwgbSA9PSBudWxsIHx8IG0oUCk7XG4gIH0sIEMgPSAoUCkgPT4ge1xuICAgIHAgPT0gbnVsbCB8fCBwKFApLCAhUC5kZWZhdWx0UHJldmVudGVkICYmIGsoITEpLCBnID09IG51bGwgfHwgZyhQKTtcbiAgfSwgSCA9IGooXG4gICAgKFApID0+IHtcbiAgICAgIFAudGFyZ2V0ID09PSB2ID8gUyghMCkgOiBTKCExKTtcbiAgICB9LFxuICAgIFt2XVxuICApO1xuICByZXR1cm4geCgoKSA9PiB7XG4gICAgaWYgKCFzKVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgSCksICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBIKTtcbiAgICAgIH07XG4gIH0sIFtILCBzXSksIC8qIEBfX1BVUkVfXyAqLyBWKFUsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gbChcbiAgICAgIHIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogdSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiAkLFxuICAgICAgICBvbk1vdXNlTGVhdmU6IEMsXG4gICAgICAgIHJlZjogYixcbiAgICAgICAgLi4uaSxcbiAgICAgICAgY2hpbGRyZW46IHRcbiAgICAgIH1cbiAgICApLFxuICAgIFcgJiYgbmUuY3JlYXRlUG9ydGFsKFxuICAgICAgLyogQF9fUFVSRV9fICovIGwoXG4gICAgICAgIG4sXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IFIsXG4gICAgICAgICAgY2xhc3NOYW1lOiBMLFxuICAgICAgICAgIHN0eWxlOiBJLnBvcHBlcixcbiAgICAgICAgICAuLi5PLnBvcHBlcixcbiAgICAgICAgICByb2xlOiBcInRvb2x0aXBcIixcbiAgICAgICAgICAuLi5oLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ0b29sdGlwLWlubmVyXCIsIGNoaWxkcmVuOiBvIH0pXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBkb2N1bWVudC5ib2R5XG4gICAgKVxuICBdIH0pO1xufSwgWWUgPSB5LmZvcndhcmRSZWYoXG4gICh7XG4gICAgYXJvdW5kOiBlLFxuICAgIGJldHdlZW46IHQsXG4gICAgYm90dG9tOiBzLFxuICAgIGNlbnRlcjogcixcbiAgICBjaGlsZHJlbjogbixcbiAgICBjbGFzc05hbWU6IGEsXG4gICAgZXZlbmx5OiBjLFxuICAgIGVuZDogbyxcbiAgICBtaWRkbGU6IGksXG4gICAgc3RhcnQ6IHUsXG4gICAgdGFnOiBkID0gXCJkaXZcIixcbiAgICB0b3A6IHAsXG4gICAgLi4ubVxuICB9LCBnKSA9PiB7XG4gICAgY29uc3QgaCA9IGYoXG4gICAgICBcInJvd1wiLFxuICAgICAgZSAmJiBcImp1c3RpZnktY29udGVudC1hcm91bmRcIixcbiAgICAgIHQgJiYgXCJqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiLFxuICAgICAgcyAmJiBcImFsaWduLXNlbGYtZW5kXCIsXG4gICAgICByICYmIFwianVzdGlmeS1jb250ZW50LWNlbnRlclwiLFxuICAgICAgYyAmJiBcImp1c3RpZnR5LWNvbnRlbnQtZXZlbmx5XCIsXG4gICAgICBvICYmIFwianVzdGlmeS1jb250ZW50LWVuZFwiLFxuICAgICAgaSAmJiBcImFsaWduLXNlbGYtY2VudGVyXCIsXG4gICAgICB1ICYmIFwianVzdGlmeS1jb250ZW50LXN0YXJ0XCIsXG4gICAgICBwICYmIFwiYWxpZ24tc2VsZi1zdGFydFwiLFxuICAgICAgYVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKGQsIHsgY2xhc3NOYW1lOiBoLCAuLi5tLCByZWY6IGcsIGNoaWxkcmVuOiBuIH0pO1xuICB9XG4pO1xuWWUuZGlzcGxheU5hbWUgPSBcIk1EQlJvd1wiO1xuY29uc3QgZXMgPSAoe1xuICBhbmltYXRlOiBlLFxuICBjbGFzc05hbWU6IHQsXG4gIGljb246IHMsXG4gIGZhYjogcixcbiAgZmFzOiBuLFxuICBmYWw6IGEsXG4gIGZhcjogYyxcbiAgZmxhZzogbyxcbiAgc3BpbjogaSxcbiAgZml4ZWQ6IHUsXG4gIGZsaXA6IGQsXG4gIGxpc3Q6IHAsXG4gIHNpemU6IG0sXG4gIHB1bGw6IGcsXG4gIHB1bHNlOiBoLFxuICBjb2xvcjogdixcbiAgYm9yZGVyOiBiLFxuICByb3RhdGU6IFQsXG4gIGludmVyc2U6IFIsXG4gIHN0YWNrOiBOLFxuICBpY29uVHlwZTogayxcbiAgY2hpbGRyZW46IEQsXG4gIC4uLlNcbn0pID0+IHtcbiAgbGV0IEU7XG4gIG8gPyBFID0gXCJmbGFnXCIgOiByID8gRSA9IFwiZmFiXCIgOiBuID8gRSA9IFwiZmFzXCIgOiBjID8gRSA9IFwiZmFyXCIgOiBhID8gRSA9IFwiZmFsXCIgOiBFID0gXCJmYVwiO1xuICBjb25zdCBGID0gZihcbiAgICBrID8gYGZhLSR7a31gIDogRSxcbiAgICBlICYmIGBmYS0ke2V9YCxcbiAgICBvID8gYGZsYWctJHtvfWAgOiBzICYmIGBmYS0ke3N9YCxcbiAgICBtICYmIGBmYS0ke219YCxcbiAgICB2ICYmIGB0ZXh0LSR7dn1gLFxuICAgIGIgJiYgXCJmYS1ib3JkZXJcIixcbiAgICBUICYmIGBmYS1yb3RhdGUtJHtUfWAsXG4gICAgZyAmJiBgZmEtcHVsbC0ke2d9YCxcbiAgICBpICYmICFlICYmIFwiZmEtc3BpblwiLFxuICAgIHAgJiYgXCJmYS1saVwiLFxuICAgIHUgJiYgXCJmYS1md1wiLFxuICAgIGggJiYgIWUgJiYgXCJmYS1wdWxzZVwiLFxuICAgIFIgJiYgXCJmYS1pbnZlcnNlXCIsXG4gICAgZCAmJiBgZmEtZmxpcC0ke2R9YCxcbiAgICBOICYmIGBmYS1zdGFjay0ke059YCxcbiAgICB0XG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcImlcIiwgeyBjbGFzc05hbWU6IEYsIC4uLlMsIGNoaWxkcmVuOiBEIH0pO1xufSwgVmUgPSB5LmZvcndhcmRSZWYoXG4gICh7XG4gICAgY2xhc3NOYW1lOiBlLFxuICAgIGNoaWxkcmVuOiB0LFxuICAgIHRhZzogcyA9IFwicFwiLFxuICAgIHZhcmlhbnQ6IHIsXG4gICAgY29sb3I6IG4sXG4gICAgYmxvY2txdW90ZTogYSxcbiAgICBub3RlOiBjLFxuICAgIG5vdGVDb2xvcjogbyxcbiAgICBsaXN0VW5TdHlsZWQ6IGksXG4gICAgbGlzdEluTGluZTogdSxcbiAgICAuLi5kXG4gIH0sIHApID0+IHtcbiAgICBjb25zdCBtID0gZihcbiAgICAgIHIgJiYgcixcbiAgICAgIGEgJiYgXCJibG9ja3F1b3RlXCIsXG4gICAgICBjICYmIFwibm90ZVwiLFxuICAgICAgbiAmJiBgdGV4dC0ke259YCxcbiAgICAgIG8gJiYgYG5vdGUtJHtvfWAsXG4gICAgICBpICYmIFwibGlzdC11bnN0eWxlZFwiLFxuICAgICAgdSAmJiBcImxpc3QtaW5saW5lXCIsXG4gICAgICBlXG4gICAgKTtcbiAgICByZXR1cm4gYSAmJiAocyA9IFwiYmxvY2txdW90ZVwiKSwgKGkgfHwgdSkgJiYgKHMgPSBcInVsXCIpLCAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogbSwgcmVmOiBwLCAuLi5kLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcblZlLmRpc3BsYXlOYW1lID0gXCJNREJUeXBvZ3JhcGh5XCI7XG5jb25zdCBxZSA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjb2xvcjogdCwgdXBwZXJjYXNlOiBzLCBib2xkOiByLCBjaGlsZHJlbjogbiwgLi4uYSB9LCBjKSA9PiB7XG4gICAgY29uc3QgbyA9IGYoXG4gICAgICBcImJyZWFkY3J1bWJcIixcbiAgICAgIHIgJiYgXCJmb250LXdlaWdodC1ib2xkXCIsXG4gICAgICB0ICYmIGB0ZXh0LSR7dH1gLFxuICAgICAgcyAmJiBcInRleHQtdXBwZXJjYXNlXCIsXG4gICAgICBlXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwoXCJuYXZcIiwgeyBcImFyaWEtbGFiZWxcIjogXCJicmVhZGNydW1iXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbChcIm9sXCIsIHsgY2xhc3NOYW1lOiBvLCByZWY6IGMsIC4uLmEsIGNoaWxkcmVuOiBuIH0pIH0pO1xuICB9XG4pO1xucWUuZGlzcGxheU5hbWUgPSBcIk1EQkJyZWFkY3J1bWJcIjtcbmNvbnN0IEtlID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGFjdGl2ZTogdCwgY3VycmVudDogcyA9IFwicGFnZVwiLCBjaGlsZHJlbjogciwgLi4ubiB9LCBhKSA9PiB7XG4gICAgY29uc3QgYyA9IGYoXCJicmVhZGNydW1iLWl0ZW1cIiwgdCAmJiBcImFjdGl2ZVwiLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwoXCJsaVwiLCB7IGNsYXNzTmFtZTogYywgcmVmOiBhLCBcImFyaWEtY3VycmVudFwiOiB0ICYmIHMsIC4uLm4sIGNoaWxkcmVuOiByIH0pO1xuICB9XG4pO1xuS2UuZGlzcGxheU5hbWUgPSBcIk1EQkJyZWFkY3J1bWJJdGVtXCI7XG5jb25zdCBVZSA9IChlKSA9PiB7XG4gIGlmIChlICE9PSAhMSlcbiAgICByZXR1cm4gYG5hdmJhci1leHBhbmQtJHtlfWA7XG59LCBKZSA9IHkuZm9yd2FyZFJlZihcbiAgKHtcbiAgICBjbGFzc05hbWU6IGUsXG4gICAgY2hpbGRyZW46IHQsXG4gICAgbGlnaHQ6IHMsXG4gICAgZGFyazogcixcbiAgICBzY3JvbGxpbmc6IG4sXG4gICAgZml4ZWQ6IGEsXG4gICAgc3RpY2t5OiBjLFxuICAgIHNjcm9sbGluZ05hdmJhck9mZnNldDogbyxcbiAgICBjb2xvcjogaSxcbiAgICB0cmFuc3BhcmVudDogdSxcbiAgICBleHBhbmQ6IGQsXG4gICAgdGFnOiBwID0gXCJuYXZcIixcbiAgICBiZ0NvbG9yOiBtLFxuICAgIC4uLmdcbiAgfSwgaCkgPT4ge1xuICAgIGNvbnN0IFt2LCBiXSA9IEIoITEpLCBUID0gZihcbiAgICAgIHtcbiAgICAgICAgXCJuYXZiYXItbGlnaHRcIjogcyxcbiAgICAgICAgXCJuYXZiYXItZGFya1wiOiByLFxuICAgICAgICBcInNjcm9sbGluZy1uYXZiYXJcIjogbiB8fCBvLFxuICAgICAgICBcInRvcC1uYXYtY29sbGFwc2VcIjogdixcbiAgICAgICAgW2B0ZXh0LSR7aX1gXTogaSAmJiB1ID8gdiA6IGlcbiAgICAgIH0sXG4gICAgICBhICYmIGBmaXhlZC0ke2F9YCxcbiAgICAgIGMgJiYgXCJzdGlja3ktdG9wXCIsXG4gICAgICBcIm5hdmJhclwiLFxuICAgICAgZCAmJiBVZShkKSxcbiAgICAgIG0gJiYgYGJnLSR7bX1gLFxuICAgICAgZVxuICAgICksIFIgPSBqKCgpID0+IHtcbiAgICAgIG8gJiYgd2luZG93LnBhZ2VZT2Zmc2V0ID4gbyA/IGIoITApIDogYighMSk7XG4gICAgfSwgW29dKTtcbiAgICByZXR1cm4geCgoKSA9PiAoKG4gfHwgbykgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgUiksICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIFIpO1xuICAgIH0pLCBbUiwgbiwgb10pLCAvKiBAX19QVVJFX18gKi8gbChwLCB7IGNsYXNzTmFtZTogVCwgcm9sZTogXCJuYXZpZ2F0aW9uXCIsIC4uLmcsIHJlZjogaCwgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5KZS5kaXNwbGF5TmFtZSA9IFwiTURCTmF2YmFyXCI7XG5jb25zdCBRZSA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2hpbGRyZW46IGUsIGNsYXNzTmFtZTogdCA9IFwiXCIsIGRpc2FibGVkOiBzID0gITEsIGFjdGl2ZTogciA9ICExLCB0YWc6IG4gPSBcImFcIiwgLi4uYSB9LCBjKSA9PiB7XG4gICAgY29uc3QgbyA9IGYoXCJuYXYtbGlua1wiLCBzID8gXCJkaXNhYmxlZFwiIDogciA/IFwiYWN0aXZlXCIgOiBcIlwiLCB0KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwobiwgeyBcImRhdGEtdGVzdFwiOiBcIm5hdi1saW5rXCIsIGNsYXNzTmFtZTogbywgc3R5bGU6IHsgY3Vyc29yOiBcInBvaW50ZXJcIiB9LCByZWY6IGMsIC4uLmEsIGNoaWxkcmVuOiBlIH0pO1xuICB9XG4pO1xuUWUuZGlzcGxheU5hbWUgPSBcIk1EQk5hdmJhckxpbmtcIjtcbmNvbnN0IFplID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCB0YWc6IHMgPSBcImFcIiwgLi4uciB9LCBuKSA9PiB7XG4gICAgY29uc3QgYSA9IGYoXCJuYXZiYXItYnJhbmRcIiwgZSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKHMsIHsgY2xhc3NOYW1lOiBhLCByZWY6IG4sIC4uLnIsIGNoaWxkcmVuOiB0IH0pO1xuICB9XG4pO1xuWmUuZGlzcGxheU5hbWUgPSBcIk1EQk5hdmJhckJyYW5kXCI7XG5jb25zdCB6ZSA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2hpbGRyZW46IGUsIGNsYXNzTmFtZTogdCwgYWN0aXZlOiBzLCB0ZXh0OiByLCB0YWc6IG4gPSBcImxpXCIsIC4uLmEgfSwgYykgPT4ge1xuICAgIGNvbnN0IG8gPSBmKFwibmF2LWl0ZW1cIiwgcyAmJiBcImFjdGl2ZVwiLCByICYmIFwibmF2YmFyLXRleHRcIiwgdCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKG4sIHsgLi4uYSwgY2xhc3NOYW1lOiBvLCByZWY6IGMsIGNoaWxkcmVuOiBlIH0pO1xuICB9XG4pO1xuemUuZGlzcGxheU5hbWUgPSBcIk1EQk5hdmJhckl0ZW1cIjtcbmNvbnN0IGV0ID0geS5mb3J3YXJkUmVmKFxuICAoeyBjaGlsZHJlbjogZSwgY2xhc3NOYW1lOiB0LCByaWdodDogcywgZnVsbFdpZHRoOiByID0gITAsIGxlZnQ6IG4sIHRhZzogYSA9IFwidWxcIiwgLi4uYyB9LCBvKSA9PiB7XG4gICAgY29uc3QgaSA9IGYoXCJuYXZiYXItbmF2XCIsIHIgJiYgXCJ3LTEwMFwiLCBzICYmIFwibXMtYXV0b1wiLCBuICYmIFwibWUtYXV0b1wiLCB0KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwoYSwgeyBjbGFzc05hbWU6IGksIHJlZjogbywgLi4uYywgY2hpbGRyZW46IGUgfSk7XG4gIH1cbik7XG5ldC5kaXNwbGF5TmFtZSA9IFwiTURCTmF2YmFyTmF2XCI7XG5jb25zdCB0dCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2hpbGRyZW46IGUsIGNsYXNzTmFtZTogdCwgdGFnOiBzID0gXCJidXR0b25cIiwgLi4uciB9LCBuKSA9PiB7XG4gICAgY29uc3QgYSA9IGYoXCJuYXZiYXItdG9nZ2xlclwiLCB0KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwocywgeyAuLi5yLCBjbGFzc05hbWU6IGEsIHJlZjogbiwgY2hpbGRyZW46IGUgfSk7XG4gIH1cbik7XG50dC5kaXNwbGF5TmFtZSA9IFwiTURCTmF2YmFyVG9nZ2xlclwiO1xuY29uc3Qgc3QgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNoaWxkcmVuOiBlLCBiZ0NvbG9yOiB0LCBjb2xvcjogcywgY2xhc3NOYW1lOiByLCAuLi5uIH0sIGEpID0+IHtcbiAgICBjb25zdCBjID0gZih0ICYmIGBiZy0ke3R9YCwgcyAmJiBgdGV4dC0ke3N9YCwgcik7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKFwiZm9vdGVyXCIsIHsgY2xhc3NOYW1lOiBjLCAuLi5uLCByZWY6IGEsIGNoaWxkcmVuOiBlIH0pO1xuICB9XG4pO1xuc3QuZGlzcGxheU5hbWUgPSBcIk1EQkZvb3RlclwiO1xuY29uc3QgcnQgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNoaWxkcmVuOiBlLCBzaXplOiB0LCBjaXJjbGU6IHMsIGNlbnRlcjogciwgZW5kOiBuLCBzdGFydDogYSwgY2xhc3NOYW1lOiBjLCAuLi5vIH0sIGkpID0+IHtcbiAgICBjb25zdCB1ID0gZihcbiAgICAgIFwicGFnaW5hdGlvblwiLFxuICAgICAgciAmJiBcImp1c3RpZnktY29udGVudC1jZW50ZXJcIixcbiAgICAgIHMgJiYgXCJwYWdpbmF0aW9uLWNpcmNsZVwiLFxuICAgICAgbiAmJiBcImp1c3RpZnktY29udGVudC1lbmRcIixcbiAgICAgIHQgJiYgYHBhZ2luYXRpb24tJHt0fWAsXG4gICAgICBhICYmIFwianVzdGlmeS1jb250ZW50LXN0YXJ0XCIsXG4gICAgICBjXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwoXCJ1bFwiLCB7IGNsYXNzTmFtZTogdSwgLi4ubywgcmVmOiBpLCBjaGlsZHJlbjogZSB9KTtcbiAgfVxuKTtcbnJ0LmRpc3BsYXlOYW1lID0gXCJNREJQYWdpbmF0aW9uXCI7XG5jb25zdCBudCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2hpbGRyZW46IGUsIGNsYXNzTmFtZTogdCwgdGFnOiBzID0gXCJhXCIsIC4uLnIgfSwgbikgPT4ge1xuICAgIGNvbnN0IGEgPSBmKFwicGFnZS1saW5rXCIsIHQpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogYSwgLi4uciwgcmVmOiBuLCBjaGlsZHJlbjogZSB9KTtcbiAgfVxuKTtcbm50LmRpc3BsYXlOYW1lID0gXCJNREJQYWdpbmF0aW9uTGlua1wiO1xuY29uc3QgYXQgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNoaWxkcmVuOiBlLCBjbGFzc05hbWU6IHQsIGFjdGl2ZTogcywgZGlzYWJsZWQ6IHIsIC4uLm4gfSwgYSkgPT4ge1xuICAgIGNvbnN0IGMgPSBmKFwicGFnZS1pdGVtXCIsIHMgJiYgXCJhY3RpdmVcIiwgciAmJiBcImRpc2FibGVkXCIsIHQpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcImxpXCIsIHsgY2xhc3NOYW1lOiBjLCAuLi5uLCByZWY6IGEsIGNoaWxkcmVuOiBlIH0pO1xuICB9XG4pO1xuYXQuZGlzcGxheU5hbWUgPSBcIk1EQlBhZ2luYXRpb25JdGVtXCI7XG5jb25zdCB0cyA9ICh7XG4gIGNsYXNzTmFtZTogZSxcbiAgY2xhc3NOYW1lUmVzcG9uc2l2ZTogdCxcbiAgcmVzcG9uc2l2ZTogcyxcbiAgYWxpZ246IHIsXG4gIGJvcmRlckNvbG9yOiBuLFxuICBib3JkZXJlZDogYSxcbiAgYm9yZGVybGVzczogYyxcbiAgY2hpbGRyZW46IG8sXG4gIGNvbG9yOiBpLFxuICBob3ZlcjogdSxcbiAgc21hbGw6IGQsXG4gIHN0cmlwZWQ6IHAsXG4gIC4uLm1cbn0pID0+IHtcbiAgY29uc3QgZyA9IGYoXG4gICAgXCJ0YWJsZVwiLFxuICAgIHIgJiYgYGFsaWduLSR7cn1gLFxuICAgIG4gJiYgYGJvcmRlci0ke259YCxcbiAgICBhICYmIFwidGFibGUtYm9yZGVyZWRcIixcbiAgICBjICYmIFwidGFibGUtYm9yZGVybGVzc1wiLFxuICAgIGkgJiYgYHRhYmxlLSR7aX1gLFxuICAgIHUgJiYgXCJ0YWJsZS1ob3ZlclwiLFxuICAgIGQgJiYgXCJ0YWJsZS1zbVwiLFxuICAgIHAgJiYgXCJ0YWJsZS1zdHJpcGVkXCIsXG4gICAgZVxuICApLCBoID0gYWUoKCkgPT4gLyogQF9fUFVSRV9fICovIGwoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogZywgLi4ubSwgY2hpbGRyZW46IG8gfSksIFtvLCBnLCBtXSk7XG4gIGlmIChzKSB7XG4gICAgY29uc3QgdiA9IGYoXG4gICAgICB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gYHRhYmxlLXJlc3BvbnNpdmUtJHtzfWAgOiBcInRhYmxlLXJlc3BvbnNpdmVcIixcbiAgICAgIHRcbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogdiwgY2hpbGRyZW46IGggfSk7XG4gIH0gZWxzZVxuICAgIHJldHVybiBoO1xufSwgc3MgPSAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCBkYXJrOiBzLCBsaWdodDogciwgLi4ubiB9KSA9PiB7XG4gIGNvbnN0IGEgPSBmKHMgJiYgXCJ0YWJsZS1kYXJrXCIsIHIgJiYgXCJ0YWJsZS1saWdodFwiLCBlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKFwidGhlYWRcIiwgeyBjbGFzc05hbWU6IGEsIC4uLm4sIGNoaWxkcmVuOiB0IH0pO1xufSwgcnMgPSAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCAuLi5zIH0pID0+IHtcbiAgY29uc3QgciA9IGYoZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcInRib2R5XCIsIHsgY2xhc3NOYW1lOiByLCAuLi5zLCBjaGlsZHJlbjogdCB9KTtcbn0sIE5lID0geS5mb3J3YXJkUmVmKFxuICAoe1xuICAgIGFuaW1hdGVkOiBlLFxuICAgIGNoaWxkcmVuOiB0LFxuICAgIGNsYXNzTmFtZTogcyxcbiAgICBzdHlsZTogcixcbiAgICB0YWc6IG4gPSBcImRpdlwiLFxuICAgIHZhbHVlbm93OiBhLFxuICAgIHZhbHVlbWF4OiBjLFxuICAgIHN0cmlwZWQ6IG8sXG4gICAgYmdDb2xvcjogaSxcbiAgICB2YWx1ZW1pbjogdSxcbiAgICB3aWR0aDogZCxcbiAgICAuLi5wXG4gIH0sIG0pID0+IHtcbiAgICBjb25zdCBnID0gZihcbiAgICAgIFwicHJvZ3Jlc3MtYmFyXCIsXG4gICAgICBpICYmIGBiZy0ke2l9YCxcbiAgICAgIG8gJiYgXCJwcm9ncmVzcy1iYXItc3RyaXBlZFwiLFxuICAgICAgZSAmJiBcInByb2dyZXNzLWJhci1hbmltYXRlZFwiLFxuICAgICAgc1xuICAgICksIGggPSB7IHdpZHRoOiBgJHtkfSVgLCAuLi5yIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKFxuICAgICAgbixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBnLFxuICAgICAgICBzdHlsZTogaCxcbiAgICAgICAgcmVmOiBtLFxuICAgICAgICByb2xlOiBcInByb2dyZXNzYmFyXCIsXG4gICAgICAgIC4uLnAsXG4gICAgICAgIFwiYXJpYS12YWx1ZW5vd1wiOiBOdW1iZXIoZCkgPz8gYSxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWluXCI6IE51bWJlcih1KSxcbiAgICAgICAgXCJhcmlhLXZhbHVlbWF4XCI6IE51bWJlcihjKSxcbiAgICAgICAgY2hpbGRyZW46IHRcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuTmUuZGlzcGxheU5hbWUgPSBcIk1EQlByb2dyZXNzQmFyXCI7XG5jb25zdCBvdCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgdGFnOiBzID0gXCJkaXZcIiwgaGVpZ2h0OiByLCBzdHlsZTogbiwgLi4uYSB9LCBjKSA9PiB7XG4gICAgY29uc3QgbyA9IGYoXCJwcm9ncmVzc1wiLCBlKSwgaSA9IHsgaGVpZ2h0OiBgJHtyfXB4YCwgLi4ubiB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogbywgcmVmOiBjLCBzdHlsZTogaSwgLi4uYSwgY2hpbGRyZW46IHkuQ2hpbGRyZW4ubWFwKHQsICh1KSA9PiB7XG4gICAgICBpZiAoIXkuaXNWYWxpZEVsZW1lbnQodSkgfHwgdS50eXBlICE9PSBOZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUHJvZ3Jlc3MgY29tcG9uZW50IG9ubHkgYWxsb3dzIFByb2dyZXNzQmFyIGFzIGNoaWxkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIHU7XG4gICAgfSkgfSk7XG4gIH1cbik7XG5vdC5kaXNwbGF5TmFtZSA9IFwiTURCUHJvZ3Jlc3NcIjtcbmNvbnN0IGN0ID0gKGUpID0+IHtcbiAgY29uc3QgW3QsIHNdID0gQighMSksIHIgPSBhZSgoKSA9PiBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKFtuXSkgPT4ge1xuICAgIHMobi5pc0ludGVyc2VjdGluZyk7XG4gIH0pLCBbXSk7XG4gIHJldHVybiB4KCgpID0+IHtcbiAgICBpZiAoZS5jdXJyZW50KVxuICAgICAgcmV0dXJuIHIub2JzZXJ2ZShlLmN1cnJlbnQpLCAoKSA9PiByLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW3IsIGVdKSwgdDtcbn0sIGx0ID0gKGUsIHQpID0+IGFlKCgpID0+IHQgIT09IHZvaWQgMCA/IHQgOiBlLCBbdCwgZV0pLCBpdCA9IHkuZm9yd2FyZFJlZihcbiAgKHtcbiAgICBjbGFzc05hbWU6IGUsXG4gICAgc2l6ZTogdCxcbiAgICBjb250cmFzdDogcyxcbiAgICB2YWx1ZTogcixcbiAgICBkZWZhdWx0VmFsdWU6IG4sXG4gICAgaWQ6IGEsXG4gICAgbGFiZWxDbGFzczogYyxcbiAgICB3cmFwcGVyQ2xhc3M6IG8sXG4gICAgd3JhcHBlclN0eWxlOiBpLFxuICAgIHdyYXBwZXJUYWc6IHUgPSBcImRpdlwiLFxuICAgIGxhYmVsOiBkLFxuICAgIG9uQ2hhbmdlOiBwLFxuICAgIGNoaWxkcmVuOiBtLFxuICAgIGxhYmVsUmVmOiBnLFxuICAgIGxhYmVsU3R5bGU6IGgsXG4gICAgdHlwZTogdixcbiAgICBvbkJsdXI6IGIsXG4gICAgcmVhZG9ubHk6IFQgPSAhMSxcbiAgICBzaG93Q291bnRlcjogUiA9ICExLFxuICAgIC4uLk5cbiAgfSwgaykgPT4ge1xuICAgIHZhciBRLCBaO1xuICAgIGNvbnN0IFtELCBTXSA9IEIociB8fCBuKSwgW0UsIEZdID0gQigwKSwgW1csIHddID0gQighMSksIFtMLCBJXSA9IEIoMCksIE8gPSBxKG51bGwpLCAkID0gY3QoTyk7XG4gICAgTWUoaywgKCkgPT4gTy5jdXJyZW50KTtcbiAgICBjb25zdCBDID0gcShudWxsKSwgSCA9IGcgfHwgQywgUCA9IGYoXCJmb3JtLW91dGxpbmVcIiwgcyAmJiBcImZvcm0td2hpdGVcIiwgbyksIFggPSBmKFxuICAgICAgXCJmb3JtLWNvbnRyb2xcIixcbiAgICAgIFcgJiYgXCJhY3RpdmVcIixcbiAgICAgIHYgPT09IFwiZGF0ZVwiICYmIFwiYWN0aXZlXCIsXG4gICAgICB0ICYmIGBmb3JtLWNvbnRyb2wtJHt0fWAsXG4gICAgICBlXG4gICAgKSwgRyA9IGYoXCJmb3JtLWxhYmVsXCIsIGMpO1xuICAgIHgoKCkgPT4ge1xuICAgICAgaWYgKCFPLmN1cnJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IE0gfSA9IE8uY3VycmVudDtcbiAgICAgIE0gIT0gXCJcIiA/IHcoITApIDogdyghMSk7XG4gICAgfSwgWyhRID0gTy5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogUS52YWx1ZV0pLCB4KCgpID0+IHtcbiAgICAgIHIgIT09IHZvaWQgMCAmJiAociAhPSBcIlwiID8gdyghMCkgOiB3KCExKSk7XG4gICAgfSwgW3JdKSwgeCgoKSA9PiB7XG4gICAgICBuICE9PSB2b2lkIDAgJiYgKG4gIT0gXCJcIiA/IHcoITApIDogdyghMSkpO1xuICAgIH0sIFtuXSk7XG4gICAgY29uc3QgXyA9IGooKCkgPT4ge1xuICAgICAgdmFyIE07XG4gICAgICAoTSA9IEguY3VycmVudCkgIT0gbnVsbCAmJiBNLmNsaWVudFdpZHRoICYmIEYoSC5jdXJyZW50LmNsaWVudFdpZHRoICogMC44ICsgOCk7XG4gICAgfSwgW0hdKTtcbiAgICB4KCgpID0+IHtcbiAgICAgIF8oKTtcbiAgICB9LCBbKFogPSBILmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBaLmNsaWVudFdpZHRoLCBfLCAkXSk7XG4gICAgY29uc3QgSiA9IChNKSA9PiB7XG4gICAgICBTKE0udGFyZ2V0LnZhbHVlKSwgUiAmJiBJKE0udGFyZ2V0LnZhbHVlLmxlbmd0aCksIHAgPT0gbnVsbCB8fCBwKE0pO1xuICAgIH0sIFkgPSBqKFxuICAgICAgKE0pID0+IHtcbiAgICAgICAgTy5jdXJyZW50ICYmIChEICE9PSB2b2lkIDAgJiYgRCAhPSBcIlwiIHx8IHIgIT09IHZvaWQgMCAmJiByICE9IFwiXCIgfHwgTy5jdXJyZW50LnZhbHVlICE9IFwiXCIgPyB3KCEwKSA6IHcoITEpLCBiICYmIGIoTSkpO1xuICAgICAgfSxcbiAgICAgIFtELCByLCBiXVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBWKHUsIHsgY2xhc3NOYW1lOiBQLCBzdHlsZTogaSwgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBsKFxuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiB2LFxuICAgICAgICAgIHJlYWRPbmx5OiBULFxuICAgICAgICAgIGNsYXNzTmFtZTogWCxcbiAgICAgICAgICBvbkJsdXI6IFksXG4gICAgICAgICAgb25DaGFuZ2U6IEosXG4gICAgICAgICAgb25Gb2N1czogXyxcbiAgICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IG4sXG4gICAgICAgICAgaWQ6IGEsXG4gICAgICAgICAgcmVmOiBPLFxuICAgICAgICAgIC4uLk5cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGQgJiYgLyogQF9fUFVSRV9fICovIGwoXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogRywgc3R5bGU6IGgsIGh0bWxGb3I6IGEsIHJlZjogSCwgY2hpbGRyZW46IGQgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gVihcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLW5vdGNoXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBsKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZvcm0tbm90Y2gtbGVhZGluZ1wiIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLW5vdGNoLW1pZGRsZVwiLCBzdHlsZTogeyB3aWR0aDogRSB9IH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLW5vdGNoLXRyYWlsaW5nXCIgfSlcbiAgICAgIF0gfSksXG4gICAgICBtLFxuICAgICAgUiAmJiBOLm1heExlbmd0aCAmJiAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLWhlbHBlclwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGwoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZm9ybS1jb3VudGVyXCIsIGNoaWxkcmVuOiBgJHtMfS8ke04ubWF4TGVuZ3RofWAgfSkgfSlcbiAgICBdIH0pO1xuICB9XG4pO1xuaXQuZGlzcGxheU5hbWUgPSBcIk1EQklucHV0XCI7XG5jb25zdCB1ZSA9ICh7XG4gIGNsYXNzTmFtZTogZSxcbiAgaW5wdXRSZWY6IHQsXG4gIGxhYmVsQ2xhc3M6IHMsXG4gIHdyYXBwZXJDbGFzczogcixcbiAgbGFiZWxTdHlsZTogbixcbiAgd3JhcHBlclRhZzogYSA9IFwiZGl2XCIsXG4gIHdyYXBwZXJTdHlsZTogYyxcbiAgbGFiZWw6IG8sXG4gIGlubGluZTogaSxcbiAgYnRuOiB1LFxuICBpZDogZCxcbiAgYnRuQ29sb3I6IHAsXG4gIGRpc2FibGVXcmFwcGVyOiBtLFxuICB0b2dnbGVTd2l0Y2g6IGcsXG4gIC4uLmhcbn0pID0+IHtcbiAgbGV0IHYgPSBcImZvcm0tY2hlY2staW5wdXRcIiwgYiA9IFwiZm9ybS1jaGVjay1sYWJlbFwiO1xuICB1ICYmICh2ID0gXCJidG4tY2hlY2tcIiwgcCA/IGIgPSBgYnRuIGJ0bi0ke3B9YCA6IGIgPSBcImJ0biBidG4tcHJpbWFyeVwiKTtcbiAgY29uc3QgVCA9IGYoXG4gICAgbyAmJiAhdSAmJiBcImZvcm0tY2hlY2tcIixcbiAgICBpICYmICF1ICYmIFwiZm9ybS1jaGVjay1pbmxpbmVcIixcbiAgICBnICYmIFwiZm9ybS1zd2l0Y2hcIixcbiAgICByXG4gICksIFIgPSBmKHYsIGUpLCBOID0gZihiLCBzKSwgayA9IC8qIEBfX1BVUkVfXyAqLyBWKFUsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gbChcImlucHV0XCIsIHsgY2xhc3NOYW1lOiBSLCBpZDogZCwgcmVmOiB0LCAuLi5oIH0pLFxuICAgIG8gJiYgLyogQF9fUFVSRV9fICovIGwoXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogTiwgc3R5bGU6IG4sIGh0bWxGb3I6IGQsIGNoaWxkcmVuOiBvIH0pXG4gIF0gfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChVLCB7IGNoaWxkcmVuOiBtID8gayA6IC8qIEBfX1BVUkVfXyAqLyBsKGEsIHsgc3R5bGU6IGMsIGNsYXNzTmFtZTogVCwgY2hpbGRyZW46IGsgfSkgfSk7XG59LCBucyA9ICh7IC4uLmUgfSkgPT4gLyogQF9fUFVSRV9fICovIGwodWUsIHsgdHlwZTogXCJjaGVja2JveFwiLCAuLi5lIH0pLCBhcyA9ICh7IC4uLmUgfSkgPT4gLyogQF9fUFVSRV9fICovIGwodWUsIHsgdHlwZTogXCJyYWRpb1wiLCAuLi5lIH0pLCBkdCA9ICh7XG4gIGNsYXNzTmFtZTogZSxcbiAgY2hpbGRyZW46IHQsXG4gIG9wZW46IHMgPSAhMSxcbiAgaWQ6IHIsXG4gIG5hdmJhcjogbixcbiAgdGFnOiBhID0gXCJkaXZcIixcbiAgY29sbGFwc2VSZWY6IGMsXG4gIHN0eWxlOiBvLFxuICBvbk9wZW46IGksXG4gIG9uQ2xvc2U6IHUsXG4gIC4uLmRcbn0pID0+IHtcbiAgY29uc3QgW3AsIG1dID0gQighMSksIFtnLCBoXSA9IEIodm9pZCAwKSwgW3YsIGJdID0gQighMSksIFQgPSBmKFxuICAgIHYgPyBcImNvbGxhcHNpbmdcIiA6IFwiY29sbGFwc2VcIixcbiAgICAhdiAmJiBwICYmIFwic2hvd1wiLFxuICAgIG4gJiYgXCJuYXZiYXItY29sbGFwc2VcIixcbiAgICBlXG4gICksIFIgPSBxKG51bGwpLCBOID0gYyA/PyBSLCBrID0gaigoKSA9PiB7XG4gICAgcCAmJiBoKHZvaWQgMCk7XG4gIH0sIFtwXSk7XG4gIHJldHVybiB4KCgpID0+IHtcbiAgICB2YXIgRDtcbiAgICBnID09PSB2b2lkIDAgJiYgcCAmJiBoKChEID0gTiA9PSBudWxsID8gdm9pZCAwIDogTi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogRC5zY3JvbGxIZWlnaHQpO1xuICB9LCBbZywgcCwgTl0pLCB4KCgpID0+IHtcbiAgICBwICE9PSBzICYmIChzID8gaSA9PSBudWxsIHx8IGkoKSA6IHUgPT0gbnVsbCB8fCB1KCksIG0ocykpLCBwICYmIGIoITApO1xuICAgIGNvbnN0IEQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGIoITEpO1xuICAgIH0sIDM1MCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChEKTtcbiAgICB9O1xuICB9LCBbcywgcCwgaSwgdV0pLCB4KCgpID0+IHtcbiAgICB2YXIgRDtcbiAgICBoKHAgPyAoRCA9IE4gPT0gbnVsbCA/IHZvaWQgMCA6IE4uY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IEQuc2Nyb2xsSGVpZ2h0IDogMCk7XG4gIH0sIFtwLCBOLCB0XSksIHgoKCkgPT4gKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGspLCAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgayk7XG4gIH0pLCBba10pLCAvKiBAX19QVVJFX18gKi8gbChhLCB7IHN0eWxlOiB7IGhlaWdodDogZywgLi4ubyB9LCBpZDogciwgY2xhc3NOYW1lOiBULCAuLi5kLCByZWY6IE4sIGNoaWxkcmVuOiB0IH0pO1xufSwgd2UgPSBiZShudWxsKSwgdXQgPSAoe1xuICBjaGlsZHJlbjogZSxcbiAgaXNPcGVuOiB0ID0gITEsXG4gIG9wdGlvbnM6IHMsXG4gIGFuaW1hdGlvbjogciA9ICEwLFxuICBkcm9wdXA6IG4sXG4gIGRyb3ByaWdodDogYSxcbiAgZHJvcGxlZnQ6IGMsXG4gIG9uQ2xvc2U6IG8sXG4gIG9uT3BlbjogaVxufSkgPT4ge1xuICBjb25zdCBbdSwgZF0gPSBCKHQpLCBbcCwgbV0gPSBCKG51bGwpLCBbZywgaF0gPSBCKG51bGwpLCBbdiwgYl0gPSBCKC0xKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKFxuICAgIHdlLlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGFuaW1hdGlvbjogcixcbiAgICAgICAgYWN0aXZlSW5kZXg6IHYsXG4gICAgICAgIGlzT3BlblN0YXRlOiB1LFxuICAgICAgICBzZXRSZWZlcmVuY2VFbGVtZW50OiBtLFxuICAgICAgICBzZXRQb3BwZXJFbGVtZW50OiBoLFxuICAgICAgICBzZXRBY3RpdmVJbmRleDogYixcbiAgICAgICAgcG9wcGVyRWxlbWVudDogZyxcbiAgICAgICAgc2V0SXNPcGVuU3RhdGU6IGQsXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQ6IHAsXG4gICAgICAgIG9uQ2xvc2U6IG8sXG4gICAgICAgIG9uT3BlbjogaSxcbiAgICAgICAgZHJvcHVwOiBuLFxuICAgICAgICBvcHRpb25zOiBzLFxuICAgICAgICBkcm9wcmlnaHQ6IGEsXG4gICAgICAgIGRyb3BsZWZ0OiBjXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IGVcbiAgICB9XG4gICk7XG59LCBtdCA9IChlKSA9PiBlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQsIGZ0ID0gKGUpID0+IGUgaW5zdGFuY2VvZiBOb2RlLCByZSA9ICgpID0+IHtcbiAgY29uc3QgZSA9IHNlKHdlKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgY29udGV4dCBkYXRhXCIpO1xuICByZXR1cm4gZTtcbn0sIHB0ID0gKCkgPT4ge1xuICBjb25zdCB7IGlzT3BlblN0YXRlOiBlLCBzZXRJc09wZW5TdGF0ZTogdCwgc2V0QWN0aXZlSW5kZXg6IHMsIHBvcHBlckVsZW1lbnQ6IHIsIHJlZmVyZW5jZUVsZW1lbnQ6IG4sIG9uQ2xvc2U6IGEgfSA9IHJlKCksIGMgPSBqKFxuICAgIChvKSA9PiB7XG4gICAgICBlICYmIChhID09IG51bGwgfHwgYShvKSksICEoIWUgfHwgIWZ0KG8udGFyZ2V0KSB8fCByICYmIHIuY29udGFpbnMoby50YXJnZXQpIHx8IG4gJiYgbi5jb250YWlucyhvLnRhcmdldCkgfHwgby5kZWZhdWx0UHJldmVudGVkKSAmJiAodCghMSksIHNldFRpbWVvdXQoKCkgPT4gcygtMSksIDMwMCkpO1xuICAgIH0sXG4gICAgW2UsIHQsIHMsIHIsIG4sIGFdXG4gICk7XG4gIHgoKCkgPT4gKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgYyksICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgYykpLCBbY10pO1xufSwgZ3QgPSAoe1xuICBjbGFzc05hbWU6IGUsXG4gIHRhZzogdCA9IFwiZGl2XCIsXG4gIGdyb3VwOiBzLFxuICBjaGlsZHJlbjogcixcbiAgZHJvcHVwOiBuLFxuICBkcm9wcmlnaHQ6IGEsXG4gIGRyb3BsZWZ0OiBjLFxuICAuLi5vXG59KSA9PiB7XG4gIHB0KCk7XG4gIGNvbnN0IGkgPSBmKFxuICAgIHMgPyBcImJ0bi1ncm91cFwiIDogXCJkcm9wZG93blwiLFxuICAgIG4gJiYgXCJkcm9wdXBcIixcbiAgICBhICYmIFwiZHJvcGVuZFwiLFxuICAgIGMgJiYgXCJkcm9wc3RhcnRcIixcbiAgICBlXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbCh0LCB7IGNsYXNzTmFtZTogaSwgLi4ubywgY2hpbGRyZW46IHIgfSk7XG59LCBvcyA9ICh7IGFuaW1hdGlvbjogZSwgb25DbG9zZTogdCwgb25PcGVuOiBzLCAuLi5yIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBsKHV0LCB7IGFuaW1hdGlvbjogZSwgb25DbG9zZTogdCwgb25PcGVuOiBzLCAuLi5yLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGwoZ3QsIHsgLi4uciB9KSB9KSwgaHQgPSAoe1xuICBjaGlsZFRhZzogZSxcbiAgY2hpbGRyZW46IHQsXG4gIGRpc2FibGVkOiBzLFxuICBsaW5rOiByLFxuICBkaXZpZGVyOiBuLFxuICBoZWFkZXI6IGEsXG4gIGhyZWY6IGMgPSBcIiNcIlxufSkgPT4ge1xuICBjb25zdCBvID0gZihcImRyb3Bkb3duLWl0ZW1cIiwgcyAmJiBcImRpc2FibGVkXCIpO1xuICByZXR1cm4gciA/IGUgPyAvKiBAX19QVVJFX18gKi8gbChlLCB7IGNsYXNzTmFtZTogbywgY2hpbGRyZW46IHQgfSkgOiAvKiBAX19QVVJFX18gKi8gbChcImFcIiwgeyBocmVmOiBjLCBjbGFzc05hbWU6IG8sIGNoaWxkcmVuOiB0IH0pIDogbiA/IGUgPyAvKiBAX19QVVJFX18gKi8gbChlLCB7IGNsYXNzTmFtZTogXCJkcm9wZG93bi1kaXZpZGVyXCIsIGNoaWxkcmVuOiB0IH0pIDogLyogQF9fUFVSRV9fICovIGwoXCJoclwiLCB7IGNsYXNzTmFtZTogXCJkcm9wZG93bi1kaXZpZGVyXCIgfSkgOiBhID8gZSA/IC8qIEBfX1BVUkVfXyAqLyBsKGUsIHsgY2xhc3NOYW1lOiBcImRyb3Bkb3duLWhlYWRlclwiLCBjaGlsZHJlbjogdCB9KSA6IC8qIEBfX1BVUkVfXyAqLyBsKFwiaDZcIiwgeyBjbGFzc05hbWU6IFwiZHJvcGRvd24taGVhZGVyXCIsIGNoaWxkcmVuOiB0IH0pIDogLyogQF9fUFVSRV9fICovIGwoVSwgeyBjaGlsZHJlbjogdCB9KTtcbn07XG5jb25zdCBjcyA9ICh7XG4gIG9uQ2xpY2s6IGUsXG4gIHRhZzogdCA9IFwibGlcIixcbiAgY2hpbGRUYWc6IHMsXG4gIGNoaWxkcmVuOiByLFxuICBzdHlsZTogbixcbiAgbGluazogYSxcbiAgZGl2aWRlcjogYyxcbiAgaGVhZGVyOiBvLFxuICBkaXNhYmxlZDogaSxcbiAgaHJlZjogdSxcbiAgcHJldmVudENsb3NlT25DbGljazogZCxcbiAgLi4ucFxufSkgPT4ge1xuICBjb25zdCB7IHNldElzT3BlblN0YXRlOiBtLCBvbkNsb3NlOiBnLCBzZXRBY3RpdmVJbmRleDogaCB9ID0gcmUoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKHQsIHsgc3R5bGU6IG4sIG9uQ2xpY2s6IChiKSA9PiB7XG4gICAgZyA9PSBudWxsIHx8IGcoYiksIGUgPT0gbnVsbCB8fCBlKGIpLCAhKGkgfHwgZCB8fCBiLmRlZmF1bHRQcmV2ZW50ZWQpICYmIChzZXRUaW1lb3V0KCgpID0+IGgoLTEpLCAzMDApLCBtKCExKSk7XG4gIH0sIC4uLnAsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbChcbiAgICBodCxcbiAgICB7XG4gICAgICBsaW5rOiBhLFxuICAgICAgZGl2aWRlcjogYyxcbiAgICAgIGhlYWRlcjogbyxcbiAgICAgIGRpc2FibGVkOiBpLFxuICAgICAgaHJlZjogdSxcbiAgICAgIGNoaWxkVGFnOiBzLFxuICAgICAgY2hpbGRyZW46IHJcbiAgICB9XG4gICkgfSk7XG59LCBnZSA9IChlLCB0LCBzKSA9PiBzID09PSBcInVwXCIgPyBlIDw9IDAgPyB0W3QubGVuZ3RoIC0gMV0ucHJvcHMuZGl2aWRlciA9PT0gITAgfHwgdFt0Lmxlbmd0aCAtIDFdLnByb3BzLmRpc2FibGVkID09PSAhMCA6IHRbZSAtIDFdLnByb3BzLmRpdmlkZXIgPT09ICEwIHx8IHRbZSAtIDFdLnByb3BzLmRpc2FibGVkID09PSAhMCA6IGUgPT09IHQubGVuZ3RoIC0gMSA/IHRbMF0ucHJvcHMuZGl2aWRlciA9PT0gITAgfHwgdFswXS5wcm9wcy5kaXNhYmxlZCA9PT0gITAgOiB0W2UgKyAxXS5wcm9wcy5kaXZpZGVyID09PSAhMCB8fCB0W2UgKyAxXS5wcm9wcy5kaXNhYmxlZCA9PT0gITAsIGJ0ID0gKGUpID0+IHtcbiAgY29uc3QgeyBhY3RpdmVJbmRleDogdCwgaXNPcGVuU3RhdGU6IHMsIHNldElzT3BlblN0YXRlOiByLCBzZXRBY3RpdmVJbmRleDogbiwgb25DbG9zZTogYSB9ID0gcmUoKSwgYyA9IGooXG4gICAgKG8pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBbXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCIsIFwiVGFiXCIsIFwiRW50ZXJcIiwgXCJFc2NhcGVcIl07XG4gICAgICBpZiAoISghQXJyYXkuaXNBcnJheShlKSB8fCAhaS5pbmNsdWRlcyhvLmtleSkpKSB7XG4gICAgICAgIGlmIChtdChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKSwgby5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgby5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHUgPSBnZSh0LCBlLCBcInVwXCIpO1xuICAgICAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgICAgICBuKHUgPyBlLmxlbmd0aCAtIDEgOiAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQgPD0gMCkge1xuICAgICAgICAgICAgbih1ID8gZS5sZW5ndGggLSAyIDogZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbigoZCkgPT4gdSA/IGQgLSAyIDogZCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLmtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBvLmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgIG8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjb25zdCB1ID0gZ2UodCwgZSwgXCJkb3duXCIpO1xuICAgICAgICAgIGlmICh0ID09PSBlLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgIG4oKGQpID0+IHUgPyAwIDogZCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodCA9PT0gZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBuKHUgPyAxIDogMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG4oKGQpID0+IHUgPyBkICsgMiA6IGQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIGNvbnN0IHUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY3RpdmU9XCJ0cnVlXCJdJyksIGQgPSB1ID09IG51bGwgPyB2b2lkIDAgOiB1LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgcmV0dXJuIGQuY2xpY2soKTtcbiAgICAgICAgICBpZiAoYSA9PSBudWxsIHx8IGEobyksIG8uZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICByKCExKSwgc2V0VGltZW91dCgoKSA9PiBuKC0xKSwgMzAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICBpZiAoYSA9PSBudWxsIHx8IGEobyksIG8uZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICByKCExKSwgc2V0VGltZW91dCgoKSA9PiBuKC0xKSwgMzAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2UsIHIsIG4sIHQsIGFdXG4gICk7XG4gIHgoKCkgPT4gKHMgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYyksICgpID0+IHtcbiAgICBzICYmIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGMpO1xuICB9KSwgW3MsIGNdKSwgeCgoKSA9PiB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWFjdGl2ZT1cInRydWVcIl0nKSwgaSA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgcmV0dXJuIGkgPT0gbnVsbCB8fCBpLmZvY3VzKCksICgpID0+IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuYmx1cigpO1xuICB9LCBbdF0pO1xufSwgdnQgPSAoKSA9PiB7XG4gIGNvbnN0IHsgaXNPcGVuU3RhdGU6IGUgfSA9IHJlKCksIFt0LCBzXSA9IEIoITEpLCBbciwgbl0gPSBCKCExKSwgW2EsIGNdID0gQihlKTtcbiAgcmV0dXJuIHgoKCkgPT4ge1xuICAgIGxldCBvO1xuICAgIHJldHVybiBlIHx8IChuKCEwKSwgcyghMSksIG8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG4oITEpLCBjKCExKTtcbiAgICB9LCAzMDApKSwgZSAmJiAocyghMCksIG4oITEpLCBjKCEwKSwgbyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcyghMSk7XG4gICAgfSwgMzAwKSksICgpID0+IGNsZWFyVGltZW91dChvKTtcbiAgfSwgW2VdKSwgeyBvcGVuOiBhLCBpc0ZhZGVJbjogdCwgaXNGYWRlT3V0OiByIH07XG59O1xuY29uc3QgbHMgPSAoe1xuICBjbGFzc05hbWU6IGUsXG4gIHRhZzogdCA9IFwidWxcIixcbiAgY2hpbGRyZW46IHMsXG4gIHN0eWxlOiByLFxuICBkYXJrOiBuLFxuICByZXNwb25zaXZlOiBhID0gXCJcIixcbiAgYXBwZW5kVG9Cb2R5OiBjID0gITEsXG4gIGFsd2F5c09wZW46IG8sXG4gIC4uLmlcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZUluZGV4OiB1LFxuICAgIHNldFBvcHBlckVsZW1lbnQ6IGQsXG4gICAgaXNPcGVuU3RhdGU6IHAsXG4gICAgYW5pbWF0aW9uOiBtLFxuICAgIHJlZmVyZW5jZUVsZW1lbnQ6IGcsXG4gICAgcG9wcGVyRWxlbWVudDogaCxcbiAgICBvcHRpb25zOiB2LFxuICAgIGRyb3BsZWZ0OiBiLFxuICAgIGRyb3B1cDogVCxcbiAgICBkcm9wcmlnaHQ6IFJcbiAgfSA9IHJlKCksIHsgb3BlbjogTiwgaXNGYWRlSW46IGssIGlzRmFkZU91dDogRCB9ID0gdnQoKTtcbiAgYnQocyk7XG4gIGNvbnN0IFMgPSAoKSA9PiB7XG4gICAgaWYgKFIpXG4gICAgICByZXR1cm4gXCJyaWdodC1zdGFydFwiO1xuICAgIGlmIChiKVxuICAgICAgcmV0dXJuIFwibGVmdC1zdGFydFwiO1xuICAgIGNvbnN0IHcgPSBoICYmIGdldENvbXB1dGVkU3R5bGUoaCkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tbWRiLXBvc2l0aW9uXCIpLnRyaW0oKSA9PT0gXCJlbmRcIjtcbiAgICByZXR1cm4gVCA/IHcgPyBcInRvcC1lbmRcIiA6IFwidG9wLXN0YXJ0XCIgOiB3ID8gXCJib3R0b20tZW5kXCIgOiBcImJvdHRvbS1zdGFydFwiO1xuICB9LCB7IHN0eWxlczogRSB9ID0gZGUoZywgaCwge1xuICAgIHBsYWNlbWVudDogUygpLFxuICAgIG1vZGlmaWVyczogW1JlXSxcbiAgICAuLi52XG4gIH0pLCBGID0gZihcbiAgICBcImRyb3Bkb3duLW1lbnVcIixcbiAgICBuICYmIFwiZHJvcGRvd24tbWVudS1kYXJrXCIsXG4gICAgcCAmJiBcInNob3dcIixcbiAgICBtICYmIFwiYW5pbWF0aW9uXCIsXG4gICAgayAmJiBcImZhZGUtaW5cIixcbiAgICBEICYmIFwiZmFkZS1vdXRcIixcbiAgICBhICYmIGBkcm9wZG93bi1tZW51LSR7YX1gLFxuICAgIGVcbiAgKTtcbiAgaWYgKCFOICYmICFvKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBXID0gLyogQF9fUFVSRV9fICovIGwoXG4gICAgdCxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IEYsXG4gICAgICBzdHlsZTogeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB6SW5kZXg6IDFlMywgLi4uRS5wb3BwZXIsIC4uLnIgfSxcbiAgICAgIHJlZjogZCxcbiAgICAgIC4uLmksXG4gICAgICBjaGlsZHJlbjogRGUubWFwKFxuICAgICAgICBzLFxuICAgICAgICAodywgTCkgPT4gVGUodywge1xuICAgICAgICAgIHRhYkluZGV4OiAxLFxuICAgICAgICAgIFwiZGF0YS1hY3RpdmVcIjogdSA9PT0gTCAmJiAhMCxcbiAgICAgICAgICBjbGFzc05hbWU6IGYodSA9PT0gTCA/IFwiYWN0aXZlXCIgOiBcIlwiLCB3LnByb3BzLmNsYXNzTmFtZSlcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChVLCB7IGNoaWxkcmVuOiBjID8gdmUoVywgZG9jdW1lbnQuYm9keSkgOiBXIH0pO1xufSwgaXMgPSAoe1xuICBjbGFzc05hbWU6IGUsXG4gIHRhZzogdCA9IGxlLFxuICBjaGlsZHJlbjogcyxcbiAgb25DbGljazogcixcbiAgc3BsaXQ6IG4sXG4gIC4uLmFcbn0pID0+IHtcbiAgY29uc3QgeyBzZXRJc09wZW5TdGF0ZTogYywgc2V0UmVmZXJlbmNlRWxlbWVudDogbywgaXNPcGVuU3RhdGU6IGksIHNldEFjdGl2ZUluZGV4OiB1LCBvbkNsb3NlOiBkLCBvbk9wZW46IHAgfSA9IHJlKCksIG0gPSBmKFwiZHJvcGRvd24tdG9nZ2xlXCIsIG4gJiYgXCJkcm9wZG93bi10b2dnbGUtc3BsaXRcIiwgZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcbiAgICB0LFxuICAgIHtcbiAgICAgIG9uQ2xpY2s6IChoKSA9PiB7XG4gICAgICAgIHIgPT0gbnVsbCB8fCByKGgpLCBpID8gZCA9PSBudWxsIHx8IGQoaCkgOiBwID09IG51bGwgfHwgcChoKSwgIWguZGVmYXVsdFByZXZlbnRlZCAmJiAoYygodikgPT4gIXYpLCBzZXRUaW1lb3V0KCgpID0+IHUoLTEpLCAzMDApKTtcbiAgICAgIH0sXG4gICAgICByZWY6IG8sXG4gICAgICBjbGFzc05hbWU6IG0sXG4gICAgICBcImFyaWEtZXhwYW5kZWRcIjogISFpLFxuICAgICAgLi4uYSxcbiAgICAgIGNoaWxkcmVuOiBzXG4gICAgfVxuICApO1xufSwgZHMgPSAoe1xuICBjbGFzc05hbWU6IGUsXG4gIGJ0bkNsYXNzTmFtZTogdCxcbiAgYnRuQ2hpbGRyZW46IHMsXG4gIGNoaWxkcmVuOiByLFxuICB0YWc6IG4gPSBsZSxcbiAgb25PcGVuOiBhLFxuICBvbkNsb3NlOiBjLFxuICBwb3BwZXJUYWc6IG8gPSBcImRpdlwiLFxuICBvcGVuOiBpLFxuICBwbGFjZW1lbnQ6IHUgPSBcImJvdHRvbVwiLFxuICBkaXNtaXNzOiBkLFxuICBvcHRpb25zOiBwLFxuICBwb3BlclN0eWxlOiBtLFxuICBvbkNsaWNrOiBnLFxuICAuLi5oXG59KSA9PiB7XG4gIGNvbnN0IFt2LCBiXSA9IEIoKSwgW1QsIFJdID0gQigpLCB7IHN0eWxlczogTiwgYXR0cmlidXRlczogayB9ID0gZGUodiwgVCwgeyBwbGFjZW1lbnQ6IHUsIC4uLnAgfSksIFtELCBTXSA9IEIoaSA/PyAhMSksIEUgPSBsdChELCBpKSwgW0YsIFddID0gQighMSksIFt3LCBMXSA9IEIoITEpLCBJID0gZihcInBvcG92ZXIgZmFkZVwiLCBGICYmIEUgJiYgXCJzaG93XCIsIGUpLCBPID0gKEMpID0+IHtcbiAgICBFICYmICFkID8gYyA9PSBudWxsIHx8IGMoKSA6IEUgfHwgYSA9PSBudWxsIHx8IGEoKSwgZCA/IChMKCEwKSwgUyghMCkpIDogUyghRSksIGcgJiYgZyhDKTtcbiAgfSwgJCA9IGooXG4gICAgKEMpID0+IHtcbiAgICAgIHcgJiYgVCAmJiBFICYmIHYgJiYgIXYuY29udGFpbnMoQy50YXJnZXQpICYmIChTKCExKSwgYyA9PSBudWxsIHx8IGMoKSk7XG4gICAgfSxcbiAgICBbdywgRSwgVCwgdiwgY11cbiAgKTtcbiAgcmV0dXJuIHgoKCkgPT4ge1xuICAgIGNvbnN0IEMgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIFcoRSk7XG4gICAgfSwgMTUwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KEMpO1xuICAgIH07XG4gIH0sIFtFXSksIHgoKCkgPT4gKEUgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAkKSwgKCkgPT4ge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgJCk7XG4gIH0pLCBbJCwgRV0pLCAvKiBAX19QVVJFX18gKi8gVihVLCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGwobiwgeyBvbkNsaWNrOiBPLCBjbGFzc05hbWU6IHQsIC4uLmgsIHJlZjogYiwgY2hpbGRyZW46IHMgfSksXG4gICAgKEYgfHwgRSkgJiYgbmUuY3JlYXRlUG9ydGFsKFxuICAgICAgLyogQF9fUFVSRV9fICovIGwoXG4gICAgICAgIG8sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6IEksXG4gICAgICAgICAgcmVmOiBSLFxuICAgICAgICAgIHN0eWxlOiB7IC4uLk4ucG9wcGVyLCAuLi5tIH0sXG4gICAgICAgICAgLi4uay5wb3BwZXIsXG4gICAgICAgICAgY2hpbGRyZW46IHJcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGRvY3VtZW50LmJvZHlcbiAgICApXG4gIF0gfSk7XG59LCB1cyA9ICh7XG4gIGNsYXNzTmFtZTogZSxcbiAgY2hpbGRyZW46IHQsXG4gIHRhZzogcyA9IFwiZGl2XCIsXG4gIC4uLnJcbn0pID0+IHtcbiAgY29uc3QgbiA9IGYoXCJwb3BvdmVyLWJvZHlcIiwgZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogbiwgLi4uciwgY2hpbGRyZW46IHQgfSk7XG59LCBtcyA9ICh7XG4gIGNsYXNzTmFtZTogZSxcbiAgY2hpbGRyZW46IHQsXG4gIHRhZzogcyA9IFwiaDNcIixcbiAgLi4uclxufSkgPT4ge1xuICBjb25zdCBuID0gZihcInBvcG92ZXItaGVhZGVyXCIsIGUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwocywgeyBjbGFzc05hbWU6IG4sIC4uLnIsIGNoaWxkcmVuOiB0IH0pO1xufSwgZnMgPSAoe1xuICBhbmltYXRpb25EaXJlY3Rpb246IGUsXG4gIGFwcGVuZFRvQm9keTogdCxcbiAgYmFja2Ryb3A6IHMgPSAhMCxcbiAgY2hpbGRyZW46IHIsXG4gIGNsYXNzTmFtZTogbixcbiAgY2xvc2VPbkVzYzogYSA9ICEwLFxuICBzZXRPcGVuOiBjLFxuICBsZWF2ZUhpZGRlbk1vZGFsOiBvID0gITAsXG4gIG1vZGFsUmVmOiBpLFxuICBvbkNsb3NlOiB1LFxuICBvbkNsb3NlUHJldmVudGVkOiBkLFxuICBvbk9wZW46IHAsXG4gIG9wZW46IG0sXG4gIHN0YXRpY0JhY2tkcm9wOiBnLFxuICBub25JbnZhc2l2ZTogaCA9ICExLFxuICB0YWc6IHYgPSBcImRpdlwiLFxuICAuLi5iXG59KSA9PiB7XG4gIGNvbnN0IFtULCBSXSA9IEIobSksIFtOLCBrXSA9IEIobSksIFtELCBTXSA9IEIobSksIFtFLCBGXSA9IEIoITEpLCBbVywgd10gPSBCKDApLCBbTCwgSV0gPSBCKFtdKSwgTyA9IHEobnVsbCksICQgPSBpIHx8IE8sIEMgPSBmKFxuICAgIFwibW9kYWxcIixcbiAgICBFICYmIFwibW9kYWwtc3RhdGljXCIsXG4gICAgZSxcbiAgICBcImZhZGVcIixcbiAgICBOICYmIFwic2hvd1wiLFxuICAgIFQgJiYgaCAmJiBcIm1vZGFsLW5vbi1pbnZhc2l2ZS1zaG93XCIsXG4gICAgblxuICApLCBIID0gZihcIm1vZGFsLWJhY2tkcm9wXCIsIFwiZmFkZVwiLCBUICYmIFwic2hvd1wiKSwgUCA9IGooKCkgPT4ge1xuICAgIGsoKFkpID0+IChZICYmICh1ID09IG51bGwgfHwgdSgpKSwgITEpKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBSKCExKSwgYyA9PSBudWxsIHx8IGMoITEpO1xuICAgIH0sIDE1MCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgUyghMSk7XG4gICAgfSwgMzUwKTtcbiAgfSwgW3UsIGNdKSwgWCA9IGooXG4gICAgKFkpID0+IHtcbiAgICAgIGggfHwgTiAmJiBZLnRhcmdldCA9PT0gJC5jdXJyZW50ICYmIChnID8gKEYoITApLCBkID09IG51bGwgfHwgZCgpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgRighMSk7XG4gICAgICB9LCAzMDApKSA6IFAoKSk7XG4gICAgfSxcbiAgICBbTiwgJCwgZywgUCwgZCwgaF1cbiAgKSwgRyA9IGooXG4gICAgKFkpID0+IHtcbiAgICAgIE4gJiYgWS5rZXkgPT09IFwiVGFiXCIgJiYgKFkucHJldmVudERlZmF1bHQoKSwgdyhXICsgMSkpLCBhICYmIE4gJiYgWS5rZXkgPT09IFwiRXNjYXBlXCIgJiYgKGcgPyAoRighMCksIGQgPT0gbnVsbCB8fCBkKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBGKCExKTtcbiAgICAgIH0sIDMwMCkpIDogUCgpKTtcbiAgICB9LFxuICAgIFtOLCBhLCBXLCBnLCBQLCBkXVxuICApO1xuICB4KCgpID0+IHtcbiAgICB2YXIgWjtcbiAgICBjb25zdCBZID0gKFogPSAkLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBaLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICBcImJ1dHRvbiwgYSwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF1cIlxuICAgICksIFEgPSBBcnJheS5mcm9tKFkpLmZpbHRlcigoTSkgPT4gTS50YWJJbmRleCAhPT0gLTEpLnNvcnQoKE0sIEEpID0+IE0udGFiSW5kZXggPT09IEEudGFiSW5kZXggPyAwIDogQS50YWJJbmRleCA9PT0gbnVsbCA/IC0xIDogTS50YWJJbmRleCA9PT0gbnVsbCA/IDEgOiBNLnRhYkluZGV4IC0gQS50YWJJbmRleCk7XG4gICAgSShRKSwgdyhRLmxlbmd0aCAtIDEpO1xuICB9LCBbJF0pLCB4KCgpID0+IHtcbiAgICBMICYmIEwubGVuZ3RoID4gMCAmJiAoVyA9PT0gTC5sZW5ndGggPyAoTFswXS5mb2N1cygpLCB3KDApKSA6IExbV10uZm9jdXMoKSk7XG4gIH0sIFtXLCBMXSksIHgoKCkgPT4ge1xuICAgIGNvbnN0IFkgPSAoKSA9PiB7XG4gICAgICBjb25zdCBaID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gWik7XG4gICAgfSwgUSA9IHdpbmRvdy5pbm5lcldpZHRoID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoICYmIHdpbmRvdy5pbm5lcldpZHRoID49IDU3NjtcbiAgICBpZiAoRCAmJiBRICYmICFoKSB7XG4gICAgICBjb25zdCBaID0gWSgpO1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwibW9kYWwtb3BlblwiKSwgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7Wn1weGA7XG4gICAgfSBlbHNlXG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2RhbC1vcGVuXCIpLCBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJcIiwgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2RhbC1vcGVuXCIpLCBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJcIiwgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIlwiO1xuICAgIH07XG4gIH0sIFtELCBoXSksIHgoKCkgPT4ge1xuICAgIG0gPyAocCA9PSBudWxsIHx8IHAoKSwgUyghMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgUighMCk7XG4gICAgfSwgMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgayghMCksIGMgPT0gbnVsbCB8fCBjKCEwKTtcbiAgICB9LCAxNTApKSA6IFAoKTtcbiAgfSwgW20sIFAsIGMsIHBdKSwgeCgoKSA9PiB7XG4gICAgY29uc3QgWSA9IChRKSA9PiB7XG4gICAgICBRLnRhcmdldC5jbG9zZXN0KFwiLm1vZGFsLWRpYWxvZ1wiKSB8fCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgWCwgeyBvbmNlOiAhMCB9KTtcbiAgICB9O1xuICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBZKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIEcpLCAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBZKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIEcpO1xuICAgIH07XG4gIH0sIFtHLCBYXSk7XG4gIGNvbnN0IF8gPSAvKiBAX19QVVJFX18gKi8gbChVLCB7IGNoaWxkcmVuOiAobyB8fCBtIHx8IEQpICYmIG5lLmNyZWF0ZVBvcnRhbChcbiAgICAvKiBAX19QVVJFX18gKi8gVihVLCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gbChcbiAgICAgICAgdixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogQyxcbiAgICAgICAgICByZWY6ICQsXG4gICAgICAgICAgc3R5bGU6IHsgZGlzcGxheTogRCB8fCBtID8gXCJibG9ja1wiIDogXCJub25lXCIsIHBvaW50ZXJFdmVudHM6IGggPyBcIm5vbmVcIiA6IFwiaW5pdGlhbFwiIH0sXG4gICAgICAgICAgLi4uYixcbiAgICAgICAgICBjaGlsZHJlbjogclxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmUuY3JlYXRlUG9ydGFsKFxuICAgICAgICBzICYmIEQgJiYgIWggJiYgLyogQF9fUFVSRV9fICovIGwoXCJkaXZcIiwgeyBjbGFzc05hbWU6IEggfSksXG4gICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgIClcbiAgICBdIH0pLFxuICAgIGRvY3VtZW50LmJvZHlcbiAgKSB9KSwgSiA9IC8qIEBfX1BVUkVfXyAqLyBsKFUsIHsgY2hpbGRyZW46IChvIHx8IG0gfHwgRCkgJiYgLyogQF9fUFVSRV9fICovIFYoVSwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBsKFxuICAgICAgdixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBDLFxuICAgICAgICByZWY6ICQsXG4gICAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IEQgfHwgbSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBwb2ludGVyRXZlbnRzOiBoID8gXCJub25lXCIgOiBcImluaXRpYWxcIiB9LFxuICAgICAgICAuLi5iLFxuICAgICAgICBjaGlsZHJlbjogclxuICAgICAgfVxuICAgICksXG4gICAgbmUuY3JlYXRlUG9ydGFsKFxuICAgICAgcyAmJiBEICYmICFoICYmIC8qIEBfX1BVUkVfXyAqLyBsKFwiZGl2XCIsIHsgb25DbGljazogUCwgY2xhc3NOYW1lOiBIIH0pLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgIClcbiAgXSB9KSB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKFUsIHsgY2hpbGRyZW46IHQgPyBfIDogSiB9KTtcbn0sIHl0ID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNlbnRlcmVkOiB0LCBjaGlsZHJlbjogcywgc2l6ZTogciwgc2Nyb2xsYWJsZTogbiwgdGFnOiBhID0gXCJkaXZcIiwgLi4uYyB9LCBvKSA9PiB7XG4gICAgY29uc3QgaSA9IGYoXG4gICAgICBcIm1vZGFsLWRpYWxvZ1wiLFxuICAgICAgbiAmJiBcIm1vZGFsLWRpYWxvZy1zY3JvbGxhYmxlXCIsXG4gICAgICB0ICYmIFwibW9kYWwtZGlhbG9nLWNlbnRlcmVkXCIsXG4gICAgICByICYmIGBtb2RhbC0ke3J9YCxcbiAgICAgIGVcbiAgICApO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChhLCB7IGNsYXNzTmFtZTogaSwgLi4uYywgcmVmOiBvLCBjaGlsZHJlbjogcyB9KTtcbiAgfVxuKTtcbnl0LmRpc3BsYXlOYW1lID0gXCJNREJNb2RhbERpYWxvZ1wiO1xuY29uc3QgTnQgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNsYXNzTmFtZTogZSwgY2hpbGRyZW46IHQsIHRhZzogcyA9IFwiZGl2XCIsIC4uLnIgfSwgbikgPT4ge1xuICAgIGNvbnN0IGEgPSBmKFwibW9kYWwtY29udGVudFwiLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwocywgeyBjbGFzc05hbWU6IGEsIC4uLnIsIHJlZjogbiwgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5OdC5kaXNwbGF5TmFtZSA9IFwiTURCTW9kYWxDb250ZW50XCI7XG5jb25zdCB3dCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgdGFnOiBzID0gXCJkaXZcIiwgLi4uciB9LCBuKSA9PiB7XG4gICAgY29uc3QgYSA9IGYoXCJtb2RhbC1oZWFkZXJcIiwgZSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKHMsIHsgY2xhc3NOYW1lOiBhLCAuLi5yLCByZWY6IG4sIGNoaWxkcmVuOiB0IH0pO1xuICB9XG4pO1xud3QuZGlzcGxheU5hbWUgPSBcIk1EQk1vZGFsSGVhZGVyXCI7XG5jb25zdCBCdCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgdGFnOiBzID0gXCJoNVwiLCAuLi5yIH0sIG4pID0+IHtcbiAgICBjb25zdCBhID0gZihcIm1vZGFsLXRpdGxlXCIsIGUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogYSwgLi4uciwgcmVmOiBuLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcbkJ0LmRpc3BsYXlOYW1lID0gXCJNREJNb2RhbFRpdGxlXCI7XG5jb25zdCBNdCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgdGFnOiBzID0gXCJkaXZcIiwgLi4uciB9LCBuKSA9PiB7XG4gICAgY29uc3QgYSA9IGYoXCJtb2RhbC1ib2R5XCIsIGUpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChzLCB7IGNsYXNzTmFtZTogYSwgLi4uciwgcmVmOiBuLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcbk10LmRpc3BsYXlOYW1lID0gXCJNREJNb2RhbEJvZHlcIjtcbmNvbnN0IER0ID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGNoaWxkcmVuOiB0LCB0YWc6IHMgPSBcImRpdlwiLCAuLi5yIH0sIG4pID0+IHtcbiAgICBjb25zdCBhID0gZihcIm1vZGFsLWZvb3RlclwiLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwocywgeyBjbGFzc05hbWU6IGEsIC4uLnIsIHJlZjogbiwgY2hpbGRyZW46IHQgfSk7XG4gIH1cbik7XG5EdC5kaXNwbGF5TmFtZSA9IFwiTURCTW9kYWxGb290ZXJcIjtcbmNvbnN0IG1lID0geS5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlRWxlbWVudDogbnVsbCxcbiAgc2V0VGFyZ2V0czogbnVsbFxufSksIHBzID0gKHtcbiAgY29udGFpbmVyOiBlID0gdHlwZW9mIHdpbmRvdyAhPT0gdm9pZCAwID8gd2luZG93IDogbnVsbCxcbiAgY2xhc3NOYW1lOiB0LFxuICBjaGlsZHJlbjogcyxcbiAgb2Zmc2V0OiByID0gMTAsXG4gIC4uLm5cbn0pID0+IHtcbiAgY29uc3QgYSA9IGYoXCJzdGlja3ktdG9wXCIsIHQpLCBbYywgb10gPSBCKG51bGwpLCBbaSwgdV0gPSBCKFtdKSwgZCA9IGUgaW5zdGFuY2VvZiBXaW5kb3csIHAgPSBqKCgpID0+IHtcbiAgICB2YXIgVCwgUiwgTjtcbiAgICBpZiAoIWkubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG0gPSBkID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogKFQgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBULnNjcm9sbFRvcCwgZyA9IE51bWJlcihyKSwgaCA9IChSID0gaVtpLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogUi5jdXJyZW50LCB2ID0gKE4gPSBpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogTi5jdXJyZW50O1xuICAgIG0gKyBnIDwgdi5vZmZzZXRUb3AgJiYgbyhudWxsKSwgaS5mb3JFYWNoKChrLCBEKSA9PiB7XG4gICAgICB2YXIgVztcbiAgICAgIGNvbnN0IFMgPSAoVyA9IGlbRCArIDFdKSA9PSBudWxsID8gdm9pZCAwIDogVy5jdXJyZW50LCBFID0gay5jdXJyZW50O1xuICAgICAgaWYgKG0gPiBFLm9mZnNldFRvcCAtIGcgJiYgbSA8IChTID09IG51bGwgPyB2b2lkIDAgOiBTLm9mZnNldFRvcCkgLSBnKSB7XG4gICAgICAgIG8oRSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KSwgbSA+IGgub2Zmc2V0VG9wIC0gZyAmJiBvKGgpO1xuICB9LCBbciwgaSwgZCwgZV0pO1xuICByZXR1cm4geCgoKSA9PiB7XG4gICAgY29uc3QgbSA9IGQgPyBlIDogZSA9PSBudWxsID8gdm9pZCAwIDogZS5jdXJyZW50O1xuICAgIHJldHVybiBwKCksIG0gPT0gbnVsbCB8fCBtLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgcCksICgpID0+IHtcbiAgICAgIG0gPT0gbnVsbCB8fCBtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgcCk7XG4gICAgfTtcbiAgfSwgW3AsIGUsIGRdKSwgLyogQF9fUFVSRV9fICovIGwoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGEsIC4uLm4sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbChcInVsXCIsIHsgY2xhc3NOYW1lOiBcIm5hdiBmbGV4LWNvbHVtbiBuYXYtcGlsbHMgbWVudS1zaWRlYmFyXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbChtZS5Qcm92aWRlciwgeyB2YWx1ZTogeyBhY3RpdmVFbGVtZW50OiBjLCBzZXRUYXJnZXRzOiB1IH0sIGNoaWxkcmVuOiBzIH0pIH0pIH0pO1xufSwgZ3MgPSAoe1xuICBjbGFzc05hbWU6IGUsXG4gIGNvbGxhcHNpYmxlOiB0LFxuICB0YXJnZXRSZWY6IHMsXG4gIGNoaWxkcmVuOiByLFxuICBzdWJzZWN0aW9uczogbixcbiAgb25DbGljazogYSxcbiAgb25BY3RpdmF0ZTogYyxcbiAgLi4ub1xufSkgPT4ge1xuICB2YXIgdjtcbiAgY29uc3QgeyBhY3RpdmVFbGVtZW50OiBpLCBzZXRUYXJnZXRzOiB1IH0gPSBzZShtZSksIGQgPSAoKSA9PiBuID09IG51bGwgPyB2b2lkIDAgOiBuLnNvbWUoKGIpID0+IGIuY3VycmVudC5pZCA9PT0gKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuaWQpKSwgcCA9IChpID09IG51bGwgPyB2b2lkIDAgOiBpLmlkKSA9PT0gKCh2ID0gcy5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogdi5pZCksIG0gPSBwIHx8IGQoKTtcbiAgcCAmJiAoYyA9PSBudWxsIHx8IGMoaSA9PSBudWxsID8gdm9pZCAwIDogaS5pZCkpO1xuICBjb25zdCBnID0gZihcIm5hdi1saW5rXCIsIHQgJiYgXCJjb2xsYXBzaWJsZS1zY3JvbGxzcHlcIiwgbSAmJiBcImFjdGl2ZVwiLCBlKSwgaCA9IChiKSA9PiB7XG4gICAgY29uc3QgVCA9IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY3VycmVudDtcbiAgICBUID09IG51bGwgfHwgVC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiIH0pLCBhID09IG51bGwgfHwgYShiKTtcbiAgfTtcbiAgcmV0dXJuIHgoKCkgPT4ge1xuICAgIHUoKGIpID0+IFsuLi5iLCBzXSk7XG4gIH0sIFt1LCBzXSksIC8qIEBfX1BVUkVfXyAqLyBsKFwibGlcIiwgeyBjbGFzc05hbWU6IFwibmF2LWl0ZW1cIiwgc3R5bGU6IHsgY3Vyc29yOiBcInBvaW50ZXJcIiB9LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGwoXCJhXCIsIHsgY2xhc3NOYW1lOiBnLCBvbkNsaWNrOiBoLCAuLi5vLCBjaGlsZHJlbjogciB9KSB9KTtcbn0sIGhzID0gKHtcbiAgY29sbGFwc2libGU6IGUsXG4gIGNsYXNzTmFtZTogdCxcbiAgY2hpbGRyZW46IHMsXG4gIHN0eWxlOiByLFxuICAuLi5uXG59KSA9PiB7XG4gIGNvbnN0IFthLCBjXSA9IEIoXCIwcHhcIiksIHsgYWN0aXZlRWxlbWVudDogbyB9ID0gc2UobWUpLCBpID0gZihcIm5hdiBmbGV4LWNvbHVtblwiLCB0KSwgdSA9IHEobnVsbCk7XG4gIHgoKCkgPT4ge1xuICAgIGNvbnN0IHAgPSAoKSA9PiBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNvbWUoKGcpID0+IGcuY3VycmVudC5pZCA9PT0gKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uaWQpKSwgbSA9IHUuY3VycmVudDtcbiAgICBwKCkgPyBjKGAke20gPT0gbnVsbCA/IHZvaWQgMCA6IG0uc2Nyb2xsSGVpZ2h0fXB4YCkgOiBjKFwiMHB4XCIpO1xuICB9LCBbbywgZV0pO1xuICBjb25zdCBkID0ge1xuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIGhlaWdodDogYSxcbiAgICB0cmFuc2l0aW9uOiBcImhlaWdodCAuNXMgZWFzZVwiLFxuICAgIGZsZXhXcmFwOiBcIm5vd3JhcFwiLFxuICAgIC4uLnJcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKFwidWxcIiwgeyBjbGFzc05hbWU6IGksIHJlZjogdSwgc3R5bGU6IGUgPyBkIDogciwgLi4ubiwgY2hpbGRyZW46IHMgfSk7XG59LCBicyA9ICh7IC4uLmUgfSkgPT4gLyogQF9fUFVSRV9fICovIGwodWUsIHsgdHlwZTogXCJjaGVja2JveFwiLCB0b2dnbGVTd2l0Y2g6ICEwLCAuLi5lIH0pLCBUdCA9ICh7IHZhbHVlOiBlLCBtaW46IHQgPSBcIjBcIiwgbWF4OiBzID0gXCIxMDBcIiwgc2hvd1RodW1iOiByIH0pID0+IHtcbiAgY29uc3QgbiA9IE51bWJlcihlKSwgW2EsIGNdID0gQihcbiAgICAobiB8fCAwIC0gTnVtYmVyKHQpKSAqIDEwMCAvIChOdW1iZXIocykgLSBOdW1iZXIodCkpXG4gICksIG8gPSBmKFwidGh1bWJcIiwgciAmJiBcInRodW1iLWFjdGl2ZVwiKTtcbiAgcmV0dXJuIHgoKCkgPT4ge1xuICAgIGMoKE51bWJlcihlKSAtIE51bWJlcih0KSkgKiAxMDAgLyAoTnVtYmVyKHMpIC0gTnVtYmVyKHQpKSk7XG4gIH0sIFtlLCBzLCB0XSksIC8qIEBfX1BVUkVfXyAqLyBsKFwic3BhblwiLCB7IGNsYXNzTmFtZTogbywgc3R5bGU6IHsgbGVmdDogYGNhbGMoJHthfSUgKyAoJHs4IC0gYSAqIDAuMTV9cHgpKWAgfSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBsKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJ0aHVtYi12YWx1ZVwiLCBjaGlsZHJlbjogZSB9KSB9KTtcbn0sIHZzID0gKHtcbiAgY2xhc3NOYW1lOiBlLFxuICBkZWZhdWx0VmFsdWU6IHQgPSAwLFxuICBkaXNhYmxlVG9vbHRpcDogcyxcbiAgbGFiZWxJZDogcixcbiAgbWF4OiBuLFxuICBtaW46IGEsXG4gIG9uTW91c2VEb3duOiBjLFxuICBvbk1vdXNlVXA6IG8sXG4gIG9uVG91Y2hTdGFydDogaSxcbiAgb25Ub3VjaEVuZDogdSxcbiAgb25DaGFuZ2U6IGQsXG4gIGxhYmVsQ2xhc3M6IHAsXG4gIHZhbHVlOiBtLFxuICBsYWJlbDogZyxcbiAgaWQ6IGgsXG4gIGlucHV0UmVmOiB2LFxuICAuLi5iXG59KSA9PiB7XG4gIGNvbnN0IFtULCBSXSA9IEIodCksIFtOLCBrXSA9IEIoITEpLCBEID0gZihcImZvcm0tcmFuZ2VcIiwgZSksIFMgPSBmKFwiZm9ybS1sYWJlbFwiLCBwKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBWKFUsIHsgY2hpbGRyZW46IFtcbiAgICBnICYmIC8qIEBfX1BVUkVfXyAqLyBsKFwibGFiZWxcIiwgeyBjbGFzc05hbWU6IFMsIGlkOiByLCBodG1sRm9yOiBoLCBjaGlsZHJlbjogZyB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gVihcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyYW5nZVwiLCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGwoXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICBvbk1vdXNlRG93bjogKEkpID0+IHtcbiAgICAgICAgICAgIGsoITApLCBjICYmIGMoSSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbk1vdXNlVXA6IChJKSA9PiB7XG4gICAgICAgICAgICBrKCExKSwgbyAmJiBvKEkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Ub3VjaFN0YXJ0OiAoSSkgPT4ge1xuICAgICAgICAgICAgayghMCksIGkgJiYgaShJKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVG91Y2hFbmQ6IChJKSA9PiB7XG4gICAgICAgICAgICBrKCExKSwgdSAmJiB1KEkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25DaGFuZ2U6IChJKSA9PiB7XG4gICAgICAgICAgICBSKEkudGFyZ2V0LnZhbHVlKSwgZCAmJiBkKEkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xhc3NOYW1lOiBELFxuICAgICAgICAgIHZhbHVlOiBtIHx8IFQsXG4gICAgICAgICAgaWQ6IGgsXG4gICAgICAgICAgbWluOiBhLFxuICAgICAgICAgIG1heDogbixcbiAgICAgICAgICByZWY6IHYsXG4gICAgICAgICAgLi4uYlxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgIXMgJiYgLyogQF9fUFVSRV9fICovIGwoVHQsIHsgdmFsdWU6IG0gfHwgVCwgc2hvd1RodW1iOiBOLCBtaW46IGEsIG1heDogbiB9KVxuICAgIF0gfSlcbiAgXSB9KTtcbn0sIHlzID0gKHsgY2xhc3NOYW1lOiBlLCBsYWJlbENsYXNzOiB0LCBsYWJlbFN0eWxlOiBzLCBpbnB1dFJlZjogciwgc2l6ZTogbiwgbGFiZWw6IGEsIGlkOiBjLCAuLi5vIH0pID0+IHtcbiAgY29uc3QgaSA9IGYoXCJmb3JtLWNvbnRyb2xcIiwgYGZvcm0tY29udHJvbC0ke259YCwgZSksIHUgPSBmKFwiZm9ybS1sYWJlbFwiLCB0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBWKFUsIHsgY2hpbGRyZW46IFtcbiAgICBhICYmIC8qIEBfX1BVUkVfXyAqLyBsKFwibGFiZWxcIiwgeyBjbGFzc05hbWU6IHUsIHN0eWxlOiBzLCBodG1sRm9yOiBjLCBjaGlsZHJlbjogYSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gbChcImlucHV0XCIsIHsgY2xhc3NOYW1lOiBpLCB0eXBlOiBcImZpbGVcIiwgaWQ6IGMsIHJlZjogciwgLi4ubyB9KVxuICBdIH0pO1xufSwgUnQgPSB5LmZvcndhcmRSZWYoXG4gICh7XG4gICAgY2xhc3NOYW1lOiBlLFxuICAgIGNoaWxkcmVuOiB0LFxuICAgIG5vQm9yZGVyOiBzLFxuICAgIHRleHRCZWZvcmU6IHIsXG4gICAgdGV4dEFmdGVyOiBuLFxuICAgIG5vV3JhcDogYSxcbiAgICB0YWc6IGMgPSBcImRpdlwiLFxuICAgIHRleHRUYWc6IG8gPSBcInNwYW5cIixcbiAgICB0ZXh0Q2xhc3M6IGksXG4gICAgc2l6ZTogdSxcbiAgICB0ZXh0UHJvcHM6IGQsXG4gICAgLi4ucFxuICB9LCBtKSA9PiB7XG4gICAgY29uc3QgZyA9IGYoXCJpbnB1dC1ncm91cFwiLCBhICYmIFwiZmxleC1ub3dyYXBcIiwgdSAmJiBgaW5wdXQtZ3JvdXAtJHt1fWAsIGUpLCBoID0gZihcImlucHV0LWdyb3VwLXRleHRcIiwgcyAmJiBcImJvcmRlci0wXCIsIGkpLCB2ID0gKGIpID0+IC8qIEBfX1BVUkVfXyAqLyBsKFUsIHsgY2hpbGRyZW46IGIgJiYgQXJyYXkuaXNBcnJheShiKSA/IGIubWFwKChULCBSKSA9PiAvKiBAX19QVVJFX18gKi8gbChvLCB7IGNsYXNzTmFtZTogaCwgLi4uZCwgY2hpbGRyZW46IFQgfSwgUikpIDogLyogQF9fUFVSRV9fICovIGwobywgeyBjbGFzc05hbWU6IGgsIC4uLmQsIGNoaWxkcmVuOiBiIH0pIH0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gVihjLCB7IGNsYXNzTmFtZTogZywgcmVmOiBtLCAuLi5wLCBjaGlsZHJlbjogW1xuICAgICAgciAmJiB2KHIpLFxuICAgICAgdCxcbiAgICAgIG4gJiYgdihuKVxuICAgIF0gfSk7XG4gIH1cbik7XG5SdC5kaXNwbGF5TmFtZSA9IFwiTURCSW5wdXRHcm91cFwiO1xuY29uc3QgJHQgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNsYXNzTmFtZTogZSwgY2hpbGRyZW46IHQsIGlzVmFsaWRhdGVkOiBzID0gITEsIG9uUmVzZXQ6IHIsIG9uU3VibWl0OiBuLCBub1ZhbGlkYXRlOiBhID0gITAsIC4uLmMgfSwgbykgPT4ge1xuICAgIGNvbnN0IFtpLCB1XSA9IEIocyksIGQgPSBmKFwibmVlZHMtdmFsaWRhdGlvblwiLCBpICYmIFwid2FzLXZhbGlkYXRlZFwiLCBlKSwgcCA9IChnKSA9PiB7XG4gICAgICBnLnByZXZlbnREZWZhdWx0KCksIHUoITApLCBuICYmIG4oZyk7XG4gICAgfSwgbSA9IChnKSA9PiB7XG4gICAgICBnLnByZXZlbnREZWZhdWx0KCksIHUoITEpLCByICYmIHIoZyk7XG4gICAgfTtcbiAgICByZXR1cm4geCgoKSA9PiB7XG4gICAgICB1KHMpO1xuICAgIH0sIFtzXSksIC8qIEBfX1BVUkVfXyAqLyBsKFxuICAgICAgXCJmb3JtXCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogZCxcbiAgICAgICAgb25TdWJtaXQ6IHAsXG4gICAgICAgIG9uUmVzZXQ6IG0sXG4gICAgICAgIHJlZjogbyxcbiAgICAgICAgbm9WYWxpZGF0ZTogYSxcbiAgICAgICAgLi4uYyxcbiAgICAgICAgY2hpbGRyZW46IHRcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuJHQuZGlzcGxheU5hbWUgPSBcIk1EQlZhbGlkYXRpb25cIjtcbmNvbnN0IEV0ID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIGZpbGw6IHQsIHBpbGxzOiBzLCBqdXN0aWZ5OiByLCBjaGlsZHJlbjogbiwgLi4uYSB9LCBjKSA9PiB7XG4gICAgY29uc3QgbyA9IGYoXG4gICAgICBcIm5hdlwiLFxuICAgICAgcyA/IFwibmF2LXBpbGxzXCIgOiBcIm5hdi10YWJzXCIsXG4gICAgICB0ICYmIFwibmF2LWZpbGxcIixcbiAgICAgIHIgJiYgXCJuYXYtanVzdGlmaWVkXCIsXG4gICAgICBlXG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwoXCJ1bFwiLCB7IGNsYXNzTmFtZTogbywgcmVmOiBjLCAuLi5hLCBjaGlsZHJlbjogbiB9KTtcbiAgfVxuKTtcbkV0LmRpc3BsYXlOYW1lID0gXCJNREJUYWJzXCI7XG5jb25zdCBJdCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgc3R5bGU6IHMsIHRhZzogciA9IFwibGlcIiwgLi4ubiB9LCBhKSA9PiB7XG4gICAgY29uc3QgYyA9IGYoXCJuYXYtaXRlbVwiLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwociwgeyBjbGFzc05hbWU6IGMsIHN0eWxlOiB7IGN1cnNvcjogXCJwb2ludGVyXCIsIC4uLnMgfSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgcmVmOiBhLCAuLi5uLCBjaGlsZHJlbjogdCB9KTtcbiAgfVxuKTtcbkl0LmRpc3BsYXlOYW1lID0gXCJNREJUYWJzSXRlbVwiO1xuY29uc3QgTHQgPSB5LmZvcndhcmRSZWYoXG4gICh7IGNsYXNzTmFtZTogZSwgY29sb3I6IHQsIGFjdGl2ZTogcywgb25PcGVuOiByLCBvbkNsb3NlOiBuLCBjaGlsZHJlbjogYSwgLi4uYyB9LCBvKSA9PiB7XG4gICAgY29uc3QgaSA9IGYoXCJuYXYtbGlua1wiLCBzICYmIFwiYWN0aXZlXCIsIHQgJiYgYGJnLSR7dH1gLCBlKTtcbiAgICByZXR1cm4geCgoKSA9PiB7XG4gICAgICBzID8gciA9PSBudWxsIHx8IHIoKSA6IG4gPT0gbnVsbCB8fCBuKCk7XG4gICAgfSwgW3NdKSwgLyogQF9fUFVSRV9fICovIGwoXCJhXCIsIHsgY2xhc3NOYW1lOiBpLCByZWY6IG8sIC4uLmMsIGNoaWxkcmVuOiBhIH0pO1xuICB9XG4pO1xuTHQuZGlzcGxheU5hbWUgPSBcIk1EQlRhYnNMaW5rXCI7XG5jb25zdCB4dCA9IHkuZm9yd2FyZFJlZihcbiAgKHsgY2xhc3NOYW1lOiBlLCB0YWc6IHQgPSBcImRpdlwiLCBjaGlsZHJlbjogcywgLi4uciB9LCBuKSA9PiB7XG4gICAgY29uc3QgYSA9IGYoXCJ0YWItY29udGVudFwiLCBlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwodCwgeyBjbGFzc05hbWU6IGEsIHJlZjogbiwgLi4uciwgY2hpbGRyZW46IHMgfSk7XG4gIH1cbik7XG54dC5kaXNwbGF5TmFtZSA9IFwiTURCVGFic0NvbnRlbnRcIjtcbmNvbnN0IGt0ID0geS5mb3J3YXJkUmVmKFxuICAoeyBjbGFzc05hbWU6IGUsIHRhZzogdCA9IFwiZGl2XCIsIG9wZW46IHMsIGNoaWxkcmVuOiByLCAuLi5uIH0sIGEpID0+IHtcbiAgICBjb25zdCBbYywgb10gPSBCKCExKSwgaSA9IGYoXCJ0YWItcGFuZVwiLCBcImZhZGVcIiwgYyAmJiBcInNob3dcIiwgcyAmJiBcImFjdGl2ZVwiLCBlKTtcbiAgICByZXR1cm4geCgoKSA9PiB7XG4gICAgICBsZXQgdTtcbiAgICAgIHJldHVybiBzID8gdSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvKCEwKTtcbiAgICAgIH0sIDEwMCkgOiBvKCExKSwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodSk7XG4gICAgICB9O1xuICAgIH0sIFtzXSksIC8qIEBfX1BVUkVfXyAqLyBsKHQsIHsgY2xhc3NOYW1lOiBpLCByb2xlOiBcInRhYnBhbmVsXCIsIHJlZjogYSwgLi4ubiwgY2hpbGRyZW46IHIgfSk7XG4gIH1cbik7XG5rdC5kaXNwbGF5TmFtZSA9IFwiTURCVGFic1BhbmVcIjtcbmNvbnN0IGZlID0gYmUoe1xuICBhY3RpdmU6IDBcbn0pLCBTdCA9ICh7IGltYWdlc0NvdW50OiBlLCB0bzogdCB9KSA9PiB7XG4gIGNvbnN0IHsgYWN0aXZlOiBzIH0gPSBzZShmZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbChcIm9sXCIsIHsgY2xhc3NOYW1lOiBcImNhcm91c2VsLWluZGljYXRvcnNcIiwgY2hpbGRyZW46IEFycmF5LmZyb20oQXJyYXkoZSkpLm1hcCgociwgbikgPT4gLyogQF9fUFVSRV9fICovIGwoXCJsaVwiLCB7IFwiZGF0YS1tZGItdGFyZ2V0XCI6IG4sIGNsYXNzTmFtZTogZihzID09PSBuICYmIFwiYWN0aXZlXCIpLCBvbkNsaWNrOiAoKSA9PiB0KG4pIH0sIG4pKSB9KTtcbn0sIEN0ID0gKHsgbW92ZTogZSB9KSA9PiAvKiBAX19QVVJFX18gKi8gVihVLCB7IGNoaWxkcmVuOiBbXG4gIC8qIEBfX1BVUkVfXyAqLyBWKFwiYVwiLCB7IHJvbGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJjYXJvdXNlbC1jb250cm9sLXByZXZcIiwgb25DbGljazogKCkgPT4gZShcInByZXZcIiksIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGwoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImNhcm91c2VsLWNvbnRyb2wtcHJldi1pY29uXCIgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGwoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInZpc3VhbGx5LWhpZGRlblwiLCBjaGlsZHJlbjogXCJQcmV2aW91c1wiIH0pXG4gIF0gfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBWKFwiYVwiLCB7IHJvbGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJjYXJvdXNlbC1jb250cm9sLW5leHRcIiwgb25DbGljazogKCkgPT4gZShcIm5leHRcIiksIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGwoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImNhcm91c2VsLWNvbnRyb2wtbmV4dC1pY29uXCIgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGwoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInZpc3VhbGx5LWhpZGRlblwiLCBjaGlsZHJlbjogXCJOZXh0XCIgfSlcbiAgXSB9KVxuXSB9KSwgQXQgPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gZ2V0Q29tcHV0ZWRTdHlsZShlKSwgcyA9IGdldENvbXB1dGVkU3R5bGUoZSA9PSBudWxsID8gdm9pZCAwIDogZS5wYXJlbnROb2RlKTtcbiAgcmV0dXJuIHQuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgcy5kaXNwbGF5ICE9PSBcIm5vbmVcIiAmJiB0LnZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCI7XG59LCBQdCA9IChlKSA9PiBBcnJheS5mcm9tKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucXVlcnlTZWxlY3RvckFsbChcIi5jYXJvdXNlbC1pdGVtXCIpKSwgRnQgPSAoZSkgPT4gZS5vZmZzZXRIZWlnaHQsIE90ID0gKGUsIHQsIHMgPSAhMCkgPT4ge1xuICBpZiAoIXMpIHtcbiAgICBoZShlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgciA9IEh0KHQpO1xuICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsICgpID0+IGhlKGUpLCB7IG9uY2U6ICEwIH0pLCBYdCh0LCByKTtcbn0sIGhlID0gKGUpID0+IHtcbiAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIGUoKTtcbn0sIEh0ID0gKGUpID0+IHtcbiAgaWYgKCFlKVxuICAgIHJldHVybiAwO1xuICBsZXQgeyB0cmFuc2l0aW9uRHVyYXRpb246IHQsIHRyYW5zaXRpb25EZWxheTogcyB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSk7XG4gIGNvbnN0IHIgPSBOdW1iZXIucGFyc2VGbG9hdCh0KSwgbiA9IE51bWJlci5wYXJzZUZsb2F0KHMpO1xuICByZXR1cm4gIXIgJiYgIW4gPyAwIDogKHQgPSB0LnNwbGl0KFwiLFwiKVswXSwgcyA9IHMuc3BsaXQoXCIsXCIpWzBdLCAoTnVtYmVyLnBhcnNlRmxvYXQodCkgKyBOdW1iZXIucGFyc2VGbG9hdChzKSkgKiAxZTMpO1xufSwgV3QgPSAoZSkgPT4ge1xuICBlLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwidHJhbnNpdGlvbmVuZFwiKSk7XG59LCBYdCA9IChlLCB0KSA9PiB7XG4gIGxldCBzID0gITE7XG4gIGNvbnN0IG4gPSB0ICsgNTtcbiAgZnVuY3Rpb24gYSgpIHtcbiAgICBzID0gITAsIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgYSk7XG4gIH1cbiAgZS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBhKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgcyB8fCBXdChlKTtcbiAgfSwgbik7XG59LCBOcyA9ICh7XG4gIGZhZGU6IGUgPSAhMSxcbiAgY2xhc3NOYW1lOiB0LFxuICBjYXJvdXNlbElubmVyQ2xhc3NOYW1lOiBzLFxuICBkYXJrOiByLFxuICBjaGlsZHJlbjogbixcbiAgaW50ZXJ2YWw6IGEgPSA1ZTMsXG4gIGtleWJvYXJkOiBjID0gITEsXG4gIHRvdWNoOiBvID0gITAsXG4gIHNob3dDb250cm9sczogaSxcbiAgc2hvd0luZGljYXRvcnM6IHUsXG4gIG9uU2xpZGU6IGQsXG4gIC4uLnBcbn0pID0+IHtcbiAgY29uc3QgbSA9IHEoW10pLCBnID0gcShudWxsKSwgaCA9IHEoMCksIHYgPSBxKCExKSwgW2IsIFRdID0gQigwKSwgW1IsIE5dID0gQigwKSwgW2ssIERdID0gQih7IGluaXRpYWxYOiAwLCBpbml0aWFsWTogMCB9KSwgW1MsIEVdID0gQighMSksIEYgPSBxKG51bGwpLCBXID0gZihcImNhcm91c2VsXCIsIFwic2xpZGVcIiwgZSAmJiBcImNhcm91c2VsLWZhZGVcIiwgciAmJiBcImNhcm91c2VsLWRhcmtcIiwgdCksIHcgPSBmKFwiY2Fyb3VzZWwtaW5uZXJcIiwgcyksIEwgPSBqKFxuICAgIChNLCBBKSA9PiB7XG4gICAgICBpZiAoQSAhPT0gdm9pZCAwKVxuICAgICAgICBoLmN1cnJlbnQgPSBBLCBUKEEpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IEsgPSBiID09PSBSIC0gMSA/IDAgOiBiICsgMSwgZWUgPSBiID09PSAwID8gUiAtIDEgOiBiIC0gMTtcbiAgICAgICAgaC5jdXJyZW50ID0gTSA9PT0gXCJuZXh0XCIgPyBLIDogZWUsIFQoTSA9PT0gXCJuZXh0XCIgPyBLIDogZWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2IsIFJdXG4gICksIEkgPSBqKCgpID0+IHtcbiAgICBnLmN1cnJlbnQgJiYgKGNsZWFySW50ZXJ2YWwoZy5jdXJyZW50KSwgZy5jdXJyZW50ID0gbnVsbCk7XG4gIH0sIFtdKSwgTyA9IGooXG4gICAgKE0sIEEsIEspID0+IHtcbiAgICAgIHZhciBwZTtcbiAgICAgIGlmICghbS5jdXJyZW50IHx8IG0uY3VycmVudC5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm47XG4gICAgICBFKCEwKTtcbiAgICAgIGNvbnN0IHogPSBtLmN1cnJlbnRbYl0sIHRlID0gQm9vbGVhbihnLmN1cnJlbnQpLCBvZSA9IE0gPT09IFwibmV4dFwiLCBjZSA9IG9lID8gXCJjYXJvdXNlbC1pdGVtLXN0YXJ0XCIgOiBcImNhcm91c2VsLWl0ZW0tZW5kXCIsIGllID0gb2UgPyBcImNhcm91c2VsLWl0ZW0tbmV4dFwiIDogXCJjYXJvdXNlbC1pdGVtLXByZXZcIjtcbiAgICAgIGlmIChBLmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKSkge1xuICAgICAgICB2LmN1cnJlbnQgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgTChNLCBLKSwgISgheiB8fCAhQSkgJiYgKHYuY3VycmVudCA9ICEwLCB0ZSAmJiBJKCksIChwZSA9IEYuY3VycmVudCkgIT0gbnVsbCAmJiBwZS5jbGFzc0xpc3QuY29udGFpbnMoXCJzbGlkZVwiKSA/IChBLmNsYXNzTGlzdC5hZGQoaWUpLCBGdChBKSwgei5jbGFzc0xpc3QuYWRkKGNlKSwgQS5jbGFzc0xpc3QuYWRkKGNlKSwgT3QoKCkgPT4ge1xuICAgICAgICBFKCExKSwgQS5jbGFzc0xpc3QucmVtb3ZlKGNlLCBpZSksIEEuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKSwgei5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIsIGllLCBjZSksIHYuY3VycmVudCA9ICExO1xuICAgICAgfSwgeiwgITApKSA6ICh6LmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIiksIEEuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKSwgdi5jdXJyZW50ID0gITEpKTtcbiAgICB9LFxuICAgIFtGLCBiLCBMLCBJXVxuICApLCAkID0gKE0pID0+IHtcbiAgICB2LmN1cnJlbnQgfHwgKHYuY3VycmVudCA9ICEwLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHYuY3VycmVudCA9ICExO1xuICAgIH0sIE0pKTtcbiAgfSwgQyA9IGooXG4gICAgKE0pID0+IHtcbiAgICAgIGNvbnN0IEEgPSBNID09PSBcInByZXZcIiwgeiA9IChoLmN1cnJlbnQgKyAoQSA/IC0xIDogMSkpICUgUiwgdGUgPSBtLmN1cnJlbnQ7XG4gICAgICByZXR1cm4geiA9PT0gLTEgPyB0ZVtSIC0gMV0gOiB0ZVt6XTtcbiAgICB9LFxuICAgIFtSXVxuICApLCBIID0gKE0pID0+IHtcbiAgICBjb25zdCBBID0gaC5jdXJyZW50LCBLID0gTSA+IEEgPyBcIm5leHRcIiA6IFwicHJldlwiLCBlZSA9IG0uY3VycmVudDtcbiAgICByZXR1cm4geyBkaXJlY3Rpb246IEssIG5leHRFbGVtZW50OiBlZVtNXSB9O1xuICB9LCBQID0gKE0pID0+IHtcbiAgICBpZiAodi5jdXJyZW50IHx8ICgkKDcwMCksIE0gPiBSIC0gMSB8fCBNIDwgMCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkaXJlY3Rpb246IEEsIG5leHRFbGVtZW50OiBLIH0gPSBIKE0pO1xuICAgIE8oQSwgSywgTSk7XG4gIH0sIFggPSBqKFxuICAgIChNKSA9PiB7XG4gICAgICBpZiAodi5jdXJyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICAkKDYwMCk7XG4gICAgICBjb25zdCBBID0gQyhNKTtcbiAgICAgIE8oTSwgQSk7XG4gICAgfSxcbiAgICBbQywgT11cbiAgKSwgRyA9IGooKCkgPT4ge1xuICAgIGNvbnN0IHsgdmlzaWJpbGl0eVN0YXRlOiBNLCBoaWRkZW46IEEgfSA9IGRvY3VtZW50O1xuICAgIGlmIChNKVxuICAgICAgcmV0dXJuIEEgfHwgIUF0KEYuY3VycmVudCkgPyB2b2lkIDAgOiBYKFwibmV4dFwiKTtcbiAgICBYKFwibmV4dFwiKTtcbiAgfSwgW0YsIFhdKSwgXyA9IGooKCkgPT4ge1xuICAgIHZhciBBLCBLO1xuICAgIGNvbnN0IE0gPSAoSyA9IChBID0gbiA9PSBudWxsID8gdm9pZCAwIDogbltiXSkgPT0gbnVsbCA/IHZvaWQgMCA6IEEucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBLLmludGVydmFsO1xuICAgIGcuY3VycmVudCAmJiAoY2xlYXJJbnRlcnZhbChnLmN1cnJlbnQpLCBnLmN1cnJlbnQgPSBudWxsKSwgZy5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoRywgTSB8fCBhKTtcbiAgfSwgW0csIGEsIG4sIGJdKSwgSiA9IChNKSA9PiB7XG4gICAgbyAmJiBEKHsgaW5pdGlhbFg6IE0udG91Y2hlc1swXS5jbGllbnRYLCBpbml0aWFsWTogTS50b3VjaGVzWzBdLmNsaWVudFkgfSk7XG4gIH0sIFkgPSAoTSkgPT4ge1xuICAgIHYuY3VycmVudCA9ICEwO1xuICAgIGNvbnN0IHsgaW5pdGlhbFg6IEEsIGluaXRpYWxZOiBLIH0gPSBrO1xuICAgIGlmICghQSB8fCAhSylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlZSA9IE0udG91Y2hlc1swXS5jbGllbnRYLCB6ID0gTS50b3VjaGVzWzBdLmNsaWVudFksIHRlID0gQSAtIGVlLCBvZSA9IEsgLSB6O1xuICAgIE1hdGguYWJzKHRlKSA+IE1hdGguYWJzKG9lKSAmJiAodGUgPiAwID8gWChcInByZXZcIikgOiBYKFwibmV4dFwiKSksIEQoeyBpbml0aWFsWDogMCwgaW5pdGlhbFk6IDAgfSk7XG4gIH0sIFEgPSAoKSA9PiB7XG4gICAgdi5jdXJyZW50ID0gITE7XG4gIH0sIFogPSBqKFxuICAgIChNKSA9PiB7XG4gICAgICBzd2l0Y2ggKE0ua2V5KSB7XG4gICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICBNLnByZXZlbnREZWZhdWx0KCksIFgoXCJwcmV2XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICAgIE0ucHJldmVudERlZmF1bHQoKSwgWChcIm5leHRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSxcbiAgICBbWF1cbiAgKTtcbiAgcmV0dXJuIHgoKCkgPT4ge1xuICAgIGlmIChjKVxuICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBaKSwgKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgWik7XG4gICAgICB9O1xuICB9LCBbWiwgY10pLCB4KCgpID0+IHtcbiAgICBjb25zdCBNID0gRi5jdXJyZW50LCBBID0gUHQoTSk7XG4gICAgbS5jdXJyZW50ID0gQSwgTihBLmxlbmd0aCk7XG4gIH0sIFtGXSksIHgoKCkgPT4ge1xuICAgIFMgJiYgKGQgPT0gbnVsbCB8fCBkKCkpO1xuICB9LCBbUywgZF0pLCB4KCgpID0+IChfKCksICgpID0+IHtcbiAgICBJKCk7XG4gIH0pLCBbXywgSV0pLCAvKiBAX19QVVJFX18gKi8gbChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIG9uVG91Y2hTdGFydDogSixcbiAgICAgIG9uVG91Y2hNb3ZlOiBZLFxuICAgICAgb25Ub3VjaEVuZDogUSxcbiAgICAgIG9uTW91c2VFbnRlcjogSSxcbiAgICAgIG9uTW91c2VMZWF2ZTogXyxcbiAgICAgIGNsYXNzTmFtZTogVyxcbiAgICAgIHJlZjogRixcbiAgICAgIC4uLnAsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGwoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHcsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gVihmZS5Qcm92aWRlciwgeyB2YWx1ZTogeyBhY3RpdmU6IGIgfSwgY2hpbGRyZW46IFtcbiAgICAgICAgdSAmJiAvKiBAX19QVVJFX18gKi8gbChTdCwgeyB0bzogUCwgaW1hZ2VzQ291bnQ6IFIgfSksXG4gICAgICAgIG4sXG4gICAgICAgIGkgJiYgLyogQF9fUFVSRV9fICovIGwoQ3QsIHsgbW92ZTogWCB9KVxuICAgICAgXSB9KSB9KVxuICAgIH1cbiAgKTtcbn0sIHdzID0gKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgaXRlbUlkOiBzLCAuLi5yIH0pID0+IHtcbiAgY29uc3QgeyBhY3RpdmU6IG4gfSA9IHNlKGZlKSwgYSA9IHEoITApLCBjID0gcShudWxsKSwgbyA9IGYoXCJjYXJvdXNlbC1pdGVtXCIsIGUpO1xuICByZXR1cm4geCgoKSA9PiB7XG4gICAgaWYgKGEuY3VycmVudCAmJiBuID09PSBzIC0gMSkge1xuICAgICAgY29uc3QgaSA9IGMuY3VycmVudDtcbiAgICAgIGkgPT0gbnVsbCB8fCBpLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgfVxuICAgIGEuY3VycmVudCA9ICExO1xuICB9LCBbbiwgc10pLCAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogbywgcmVmOiBjLCAuLi5yLCBjaGlsZHJlbjogdCB9KTtcbn0sIEJzID0gKHsgY2xhc3NOYW1lOiBlLCBjaGlsZHJlbjogdCwgLi4ucyB9KSA9PiB7XG4gIGNvbnN0IHIgPSBmKFwiY2Fyb3VzZWwtY2FwdGlvbiBkLW5vbmUgZC1tZC1ibG9ja1wiLCBlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBsKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiByLCAuLi5zLCBjaGlsZHJlbjogdCB9KTtcbn0sIEJlID0geS5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSXRlbTogMCxcbiAgc2V0QWN0aXZlSXRlbTogbnVsbCxcbiAgYWx3YXlzT3BlbjogITEsXG4gIGluaXRpYWxBY3RpdmU6IDBcbn0pLCBfdCA9IHkuZm9yd2FyZFJlZihcbiAgKHtcbiAgICBhbHdheXNPcGVuOiBlLFxuICAgIGJvcmRlcmxlc3M6IHQsXG4gICAgY2xhc3NOYW1lOiBzLFxuICAgIGZsdXNoOiByLFxuICAgIGFjdGl2ZTogbixcbiAgICBpbml0aWFsQWN0aXZlOiBhID0gMCxcbiAgICB0YWc6IGMgPSBcImRpdlwiLFxuICAgIGNoaWxkcmVuOiBvLFxuICAgIG9uQ2hhbmdlOiBpLFxuICAgIC4uLnVcbiAgfSwgZCkgPT4ge1xuICAgIGNvbnN0IHAgPSBhZSgoKSA9PiB0eXBlb2YgbiA8IFwidVwiLCBbbl0pLCBtID0gZihcImFjY29yZGlvblwiLCByICYmIFwiYWNjb3JkaW9uLWZsdXNoXCIsIHQgJiYgXCJhY2NvcmRpb24tYm9yZGVybGVzc1wiLCBzKSwgW2csIGhdID0gQihhKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGwoYywgeyBjbGFzc05hbWU6IG0sIHJlZjogZCwgLi4udSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBsKFxuICAgICAgQmUuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB7IGFjdGl2ZUl0ZW06IHAgPyBuIDogZywgc2V0QWN0aXZlSXRlbTogaCwgYWx3YXlzT3BlbjogZSwgaW5pdGlhbEFjdGl2ZTogYSwgb25DaGFuZ2U6IGkgfSxcbiAgICAgICAgY2hpbGRyZW46IG9cbiAgICAgIH1cbiAgICApIH0pO1xuICB9XG4pO1xuX3QuZGlzcGxheU5hbWUgPSBcIk1EQkFjY29yZGlvblwiO1xuY29uc3QganQgPSB5LmZvcndhcmRSZWYoXG4gICh7XG4gICAgY2xhc3NOYW1lOiBlLFxuICAgIGJvZHlDbGFzc05hbWU6IHQsXG4gICAgYm9keVN0eWxlOiBzLFxuICAgIGhlYWRlckNsYXNzTmFtZTogcixcbiAgICBjb2xsYXBzZUlkOiBuLFxuICAgIGhlYWRlclRpdGxlOiBhLFxuICAgIGhlYWRlclN0eWxlOiBjLFxuICAgIGJ0bkNsYXNzTmFtZTogbyxcbiAgICB0YWc6IGkgPSBcImRpdlwiLFxuICAgIGNoaWxkcmVuOiB1LFxuICAgIC4uLmRcbiAgfSwgcCkgPT4ge1xuICAgIGNvbnN0IHsgYWN0aXZlSXRlbTogbSwgc2V0QWN0aXZlSXRlbTogZywgYWx3YXlzT3BlbjogaCwgb25DaGFuZ2U6IHYgfSA9IHNlKEJlKSwgYiA9IGFlKCgpID0+IEFycmF5LmlzQXJyYXkobSkgPyBtLmluY2x1ZGVzKG4pIDogbSA9PT0gbiwgW20sIG5dKSwgVCA9IGYoXCJhY2NvcmRpb24taXRlbVwiLCBlKSwgUiA9IGYoXCJhY2NvcmRpb24taGVhZGVyXCIsIHIpLCBOID0gZihcImFjY29yZGlvbi1ib2R5XCIsIHQpLCBrID0gZihcImFjY29yZGlvbi1idXR0b25cIiwgIWIgJiYgXCJjb2xsYXBzZWRcIiwgbyksIEQgPSBqKFxuICAgICAgKFMpID0+IHtcbiAgICAgICAgbGV0IEUgPSBTO1xuICAgICAgICBBcnJheS5pc0FycmF5KG0pID8gbS5pbmNsdWRlcyhTKSA/IEUgPSBtLmZpbHRlcigoVykgPT4gVyAhPT0gUykgOiBFID0gaCA/IFsuLi5tLCBTXSA6IFtTXSA6IChFID0gbSA9PT0gUyA/IDAgOiBTLCBoICYmIChFID0gW0VdKSksIHYgPT0gbnVsbCB8fCB2KEUpLCBnKEUpO1xuICAgICAgfSxcbiAgICAgIFt2LCBtLCBnLCBoXVxuICAgICk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBWKGksIHsgY2xhc3NOYW1lOiBULCByZWY6IHAsIC4uLmQsIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gbChcImgyXCIsIHsgY2xhc3NOYW1lOiBSLCBzdHlsZTogYywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBsKFwiYnV0dG9uXCIsIHsgb25DbGljazogKCkgPT4gRChuKSwgY2xhc3NOYW1lOiBrLCB0eXBlOiBcImJ1dHRvblwiLCBjaGlsZHJlbjogYSB9KSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBsKGR0LCB7IGlkOiBuLnRvU3RyaW5nKCksIG9wZW46IGIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogTiwgc3R5bGU6IHMsIGNoaWxkcmVuOiB1IH0pIH0pXG4gICAgXSB9KTtcbiAgfVxuKTtcbmp0LmRpc3BsYXlOYW1lID0gXCJNREJBY2NvcmRpb25JdGVtXCI7XG5jb25zdCBNcyA9ICh7XG4gIGNsYXNzTmFtZTogZSxcbiAgc2l6ZTogdCxcbiAgY29udHJhc3Q6IHMsXG4gIHZhbHVlOiByLFxuICBkZWZhdWx0VmFsdWU6IG4sXG4gIGlkOiBhLFxuICBsYWJlbENsYXNzOiBjLFxuICB3cmFwcGVyQ2xhc3M6IG8sXG4gIHdyYXBwZXJTdHlsZTogaSxcbiAgd3JhcHBlclRhZzogdSA9IFwiZGl2XCIsXG4gIGxhYmVsOiBkLFxuICBvbkNoYW5nZTogcCxcbiAgY2hpbGRyZW46IG0sXG4gIGxhYmVsUmVmOiBnLFxuICBsYWJlbFN0eWxlOiBoLFxuICBpbnB1dFJlZjogdixcbiAgb25CbHVyOiBiLFxuICByZWFkb25seTogVCA9ICExLFxuICAuLi5SXG59KSA9PiB7XG4gIHZhciBHO1xuICBjb25zdCBOID0gcShudWxsKSwgayA9IHEobnVsbCksIEQgPSBnIHx8IE4sIFMgPSB2IHx8IGssIFtFLCBGXSA9IEIociB8fCBuKSwgW1csIHddID0gQigwKSwgW0wsIEldID0gQihcbiAgICByICE9PSB2b2lkIDAgJiYgci5sZW5ndGggPiAwIHx8IG4gIT09IHZvaWQgMCAmJiBuLmxlbmd0aCA+IDBcbiAgKSwgTyA9IGYoXCJmb3JtLW91dGxpbmVcIiwgcyAmJiBcImZvcm0td2hpdGVcIiwgbyksICQgPSBmKFwiZm9ybS1jb250cm9sXCIsIEwgJiYgXCJhY3RpdmVcIiwgdCAmJiBgZm9ybS1jb250cm9sLSR7dH1gLCBlKSwgQyA9IGYoXCJmb3JtLWxhYmVsXCIsIGMpO1xuICB4KCgpID0+IHtcbiAgICB2YXIgXztcbiAgICBELmN1cnJlbnQgJiYgKChfID0gRC5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogXy5jbGllbnRXaWR0aCkgIT09IDAgJiYgdyhELmN1cnJlbnQuY2xpZW50V2lkdGggKiAwLjggKyA4KTtcbiAgfSwgW0QsIChHID0gRC5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogRy5jbGllbnRXaWR0aF0pO1xuICBjb25zdCBIID0gKCkgPT4ge1xuICAgIEQuY3VycmVudCAmJiB3KEQuY3VycmVudC5jbGllbnRXaWR0aCAqIDAuOCArIDgpO1xuICB9O1xuICB4KCgpID0+IHtcbiAgICByICE9PSB2b2lkIDAgJiYgKHIubGVuZ3RoID4gMCA/IEkoITApIDogSSghMSkpO1xuICB9LCBbcl0pLCB4KCgpID0+IHtcbiAgICBuICE9PSB2b2lkIDAgJiYgKG4ubGVuZ3RoID4gMCA/IEkoITApIDogSSghMSkpO1xuICB9LCBbbl0pO1xuICBjb25zdCBQID0gKF8pID0+IHtcbiAgICBGKF8uY3VycmVudFRhcmdldC52YWx1ZSksIHAgJiYgcChfKTtcbiAgfSwgWCA9IGooXG4gICAgKF8pID0+IHtcbiAgICAgIEUgIT09IHZvaWQgMCAmJiBFLmxlbmd0aCA+IDAgfHwgciAhPT0gdm9pZCAwICYmIHIubGVuZ3RoID4gMCA/IEkoITApIDogSSghMSksIGIgJiYgYihfKTtcbiAgICB9LFxuICAgIFtFLCByLCBiXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFYodSwgeyBjbGFzc05hbWU6IE8sIHN0eWxlOiB7IC4uLmkgfSwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gbChcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgIHtcbiAgICAgICAgcmVhZE9ubHk6IFQsXG4gICAgICAgIGNsYXNzTmFtZTogJCxcbiAgICAgICAgb25CbHVyOiBYLFxuICAgICAgICBvbkNoYW5nZTogUCxcbiAgICAgICAgb25Gb2N1czogSCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBuLFxuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgaWQ6IGEsXG4gICAgICAgIHJlZjogUyxcbiAgICAgICAgLi4uUlxuICAgICAgfVxuICAgICksXG4gICAgZCAmJiAvKiBAX19QVVJFX18gKi8gbChcImxhYmVsXCIsIHsgY2xhc3NOYW1lOiBDLCBzdHlsZTogaCwgaHRtbEZvcjogYSwgcmVmOiBELCBjaGlsZHJlbjogZCB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gVihcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLW5vdGNoXCIsIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLW5vdGNoLWxlYWRpbmdcIiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBsKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZvcm0tbm90Y2gtbWlkZGxlXCIsIHN0eWxlOiB7IHdpZHRoOiBXIH0gfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmb3JtLW5vdGNoLXRyYWlsaW5nXCIgfSlcbiAgICBdIH0pLFxuICAgIG1cbiAgXSB9KTtcbn0sIERzID0gKHtcbiAgY2hpbGRyZW46IGUsXG4gIGludmFsaWQ6IHQsXG4gIGZlZWRiYWNrOiBzID0gXCJMb29rcyBnb29kIVwiLFxuICB0b29sdGlwOiByLFxuICB0YWc6IG4gPSBcImRpdlwiLFxuICAuLi5hXG59KSA9PiB7XG4gIGNvbnN0IFtjLCBvXSA9IEIobnVsbCksIGkgPSBxKG51bGwpLCB1ID0gZihcbiAgICB0ID8gYGludmFsaWQtJHtyID8gXCJ0b29sdGlwXCIgOiBcImZlZWRiYWNrXCJ9YCA6IGB2YWxpZC0ke3IgPyBcInRvb2x0aXBcIiA6IFwiZmVlZGJhY2tcIn1gXG4gICk7XG4gIHJldHVybiB4KCgpID0+IHtcbiAgICB2YXIgcCwgbTtcbiAgICBjb25zdCBkID0gKG0gPSAocCA9IGkuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHAucXVlcnlTZWxlY3RvcihcImlucHV0LCB0ZXh0YXJlYVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG0ucGFyZW50RWxlbWVudDtcbiAgICBkICYmIG8oZCk7XG4gIH0sIFtdKSwgLyogQF9fUFVSRV9fICovIFYobiwgeyByZWY6IGksIC4uLmEsIGNoaWxkcmVuOiBbXG4gICAgYyAmJiB2ZSgvKiBAX19QVVJFX18gKi8gbChcImRpdlwiLCB7IGNsYXNzTmFtZTogdSwgY2hpbGRyZW46IHMgfSksIGMpLFxuICAgIGVcbiAgXSB9KTtcbn07XG5leHBvcnQge1xuICBfdCBhcyBNREJBY2NvcmRpb24sXG4gIGp0IGFzIE1EQkFjY29yZGlvbkl0ZW0sXG4gIEllIGFzIE1EQkJhZGdlLFxuICBxZSBhcyBNREJCcmVhZGNydW1iLFxuICBLZSBhcyBNREJCcmVhZGNydW1iSXRlbSxcbiAgbGUgYXMgTURCQnRuLFxuICBrZSBhcyBNREJCdG5Hcm91cCxcbiAgQ2UgYXMgTURCQ2FyZCxcbiAgSGUgYXMgTURCQ2FyZEJvZHksXG4gIFdlIGFzIE1EQkNhcmRGb290ZXIsXG4gIF9lIGFzIE1EQkNhcmRHcm91cCxcbiAgQWUgYXMgTURCQ2FyZEhlYWRlcixcbiAgUXQgYXMgTURCQ2FyZEltYWdlLFxuICBadCBhcyBNREJDYXJkTGluayxcbiAgWGUgYXMgTURCQ2FyZE92ZXJsYXksXG4gIFBlIGFzIE1EQkNhcmRTdWJUaXRsZSxcbiAgT2UgYXMgTURCQ2FyZFRleHQsXG4gIEZlIGFzIE1EQkNhcmRUaXRsZSxcbiAgTnMgYXMgTURCQ2Fyb3VzZWwsXG4gIEJzIGFzIE1EQkNhcm91c2VsQ2FwdGlvbixcbiAgd3MgYXMgTURCQ2Fyb3VzZWxJdGVtLFxuICBucyBhcyBNREJDaGVja2JveCxcbiAgRWUgYXMgTURCQ29sLFxuICBkdCBhcyBNREJDb2xsYXBzZSxcbiAgJGUgYXMgTURCQ29udGFpbmVyLFxuICBvcyBhcyBNREJEcm9wZG93bixcbiAgY3MgYXMgTURCRHJvcGRvd25JdGVtLFxuICBscyBhcyBNREJEcm9wZG93bk1lbnUsXG4gIGlzIGFzIE1EQkRyb3Bkb3duVG9nZ2xlLFxuICB5cyBhcyBNREJGaWxlLFxuICBzdCBhcyBNREJGb290ZXIsXG4gIGVzIGFzIE1EQkljb24sXG4gIGl0IGFzIE1EQklucHV0LFxuICBSdCBhcyBNREJJbnB1dEdyb3VwLFxuICBqZSBhcyBNREJMaXN0R3JvdXAsXG4gIEdlIGFzIE1EQkxpc3RHcm91cEl0ZW0sXG4gIGZzIGFzIE1EQk1vZGFsLFxuICBNdCBhcyBNREJNb2RhbEJvZHksXG4gIE50IGFzIE1EQk1vZGFsQ29udGVudCxcbiAgeXQgYXMgTURCTW9kYWxEaWFsb2csXG4gIER0IGFzIE1EQk1vZGFsRm9vdGVyLFxuICB3dCBhcyBNREJNb2RhbEhlYWRlcixcbiAgQnQgYXMgTURCTW9kYWxUaXRsZSxcbiAgSmUgYXMgTURCTmF2YmFyLFxuICBaZSBhcyBNREJOYXZiYXJCcmFuZCxcbiAgemUgYXMgTURCTmF2YmFySXRlbSxcbiAgUWUgYXMgTURCTmF2YmFyTGluayxcbiAgZXQgYXMgTURCTmF2YmFyTmF2LFxuICB0dCBhcyBNREJOYXZiYXJUb2dnbGVyLFxuICBydCBhcyBNREJQYWdpbmF0aW9uLFxuICBhdCBhcyBNREJQYWdpbmF0aW9uSXRlbSxcbiAgbnQgYXMgTURCUGFnaW5hdGlvbkxpbmssXG4gIGRzIGFzIE1EQlBvcG92ZXIsXG4gIHVzIGFzIE1EQlBvcG92ZXJCb2R5LFxuICBtcyBhcyBNREJQb3BvdmVySGVhZGVyLFxuICBvdCBhcyBNREJQcm9ncmVzcyxcbiAgTmUgYXMgTURCUHJvZ3Jlc3NCYXIsXG4gIGFzIGFzIE1EQlJhZGlvLFxuICB2cyBhcyBNREJSYW5nZSxcbiAgeWUgYXMgTURCUmlwcGxlLFxuICBZZSBhcyBNREJSb3csXG4gIHBzIGFzIE1EQlNjcm9sbHNweSxcbiAgZ3MgYXMgTURCU2Nyb2xsc3B5TGluayxcbiAgaHMgYXMgTURCU2Nyb2xsc3B5U3ViTGlzdCxcbiAgU2UgYXMgTURCU3Bpbm5lcixcbiAgYnMgYXMgTURCU3dpdGNoLFxuICB0cyBhcyBNREJUYWJsZSxcbiAgcnMgYXMgTURCVGFibGVCb2R5LFxuICBzcyBhcyBNREJUYWJsZUhlYWQsXG4gIEV0IGFzIE1EQlRhYnMsXG4gIHh0IGFzIE1EQlRhYnNDb250ZW50LFxuICBJdCBhcyBNREJUYWJzSXRlbSxcbiAgTHQgYXMgTURCVGFic0xpbmssXG4gIGt0IGFzIE1EQlRhYnNQYW5lLFxuICBNcyBhcyBNREJUZXh0QXJlYSxcbiAgenQgYXMgTURCVG9vbHRpcCxcbiAgVmUgYXMgTURCVHlwb2dyYXBoeSxcbiAgJHQgYXMgTURCVmFsaWRhdGlvbixcbiAgRHMgYXMgTURCVmFsaWRhdGlvbkl0ZW1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdb-react-ui-kit/dist/mdb-react-ui-kit.esm.js\n");

/***/ })

};
;